{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"computingMicrobiome","text":"<p>Elementary cellular automata reservoir computing benchmarks and experiments.</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install -e .\n</code></pre> <p>Optional GIF support:</p> <pre><code>pip install -e .[gif]\n</code></pre>"},{"location":"#quick-start","title":"Quick start","text":"<pre><code>from computingMicrobiome.models import KOpcodeLogic\n\nmodel = KOpcodeLogic(\n    rule_number=110,\n    width=256,\n    boundary=\"periodic\",\n    recurrence=8,\n    itr=8,\n    d_period=20,\n).fit()\n\npred = model.predict([[0, 0, 0, 1, 1]])\n</code></pre>"},{"location":"#build-docs-locally","title":"Build docs locally","text":"<pre><code>pip install -e .[docs]\nmkdocs serve\n</code></pre>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#core-utilities","title":"Core utilities","text":"<p>Shared utility helpers for bit encodings and input placement.</p> <p>Elementary cellular automata utilities.</p>"},{"location":"api/#computingMicrobiome.utils.bits_lsb_to_int","title":"<code>bits_lsb_to_int(bits_lsb)</code>","text":"<p>Convert an LSB-first bit vector to an integer.</p> <p>Parameters:</p> Name Type Description Default <code>bits_lsb</code> <code>ndarray</code> <p>Bit vector of shape (n_bits,) in LSB-first order.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Integer value represented by the bit vector.</p>"},{"location":"api/#computingMicrobiome.utils.create_input_locations","title":"<code>create_input_locations(width, recurrence, input_channels, rng)</code>","text":"<p>Sample injection sites across the automaton width.</p> <p>The width is partitioned into <code>recurrence</code> segments and <code>input_channels</code> positions are sampled without replacement in each segment.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Total number of cells.</p> required <code>recurrence</code> <code>int</code> <p>Number of segments to partition the width into.</p> required <code>input_channels</code> <code>int</code> <p>Number of channels to inject per segment.</p> required <code>rng</code> <code>Generator</code> <p>NumPy random generator for sampling.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Integer array of length <code>recurrence * input_channels</code>.</p>"},{"location":"api/#computingMicrobiome.utils.flatten_history","title":"<code>flatten_history(history_list_of_arrays)</code>","text":"<p>Concatenate a list of 1D arrays into a flat feature vector.</p> <p>Parameters:</p> Name Type Description Default <code>history_list_of_arrays</code> <code>List[ndarray]</code> <p>List of 1D arrays with matching shapes.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Flattened 1D vector formed by concatenation.</p>"},{"location":"api/#computingMicrobiome.utils.int_to_bits","title":"<code>int_to_bits(i, n_bits)</code>","text":"<p>Convert an integer to an MSB-first bit vector.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int</code> <p>Integer value to convert.</p> required <code>n_bits</code> <code>int</code> <p>Number of bits in the output vector.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Bit vector of shape (n_bits,) with dtype int8.</p> Example <p>int_to_bits(5, 3).tolist() [1, 0, 1]</p>"},{"location":"api/#computingMicrobiome.utils.int_to_bits_lsb","title":"<code>int_to_bits_lsb(i, n_bits)</code>","text":"<p>Convert an integer to an LSB-first bit vector.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int</code> <p>Integer value to convert.</p> required <code>n_bits</code> <code>int</code> <p>Number of bits in the output vector.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Bit vector of shape (n_bits,) with dtype int8.</p>"},{"location":"api/#computingMicrobiome.eca.eca_rule_lkt","title":"<code>eca_rule_lkt(rule_number)</code>","text":"<p>Generate an ECA rule lookup table.</p> <p>Parameters:</p> Name Type Description Default <code>rule_number</code> <code>int</code> <p>Integer in [0, 255] specifying the rule.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Lookup table of shape (8,) with dtype int8.</p>"},{"location":"api/#computingMicrobiome.eca.eca_run","title":"<code>eca_run(x0, rule, T, boundary, rng=None)</code>","text":"<p>Simulate an elementary cellular automaton for T steps.</p> <p>Parameters:</p> Name Type Description Default <code>x0</code> <code>ndarray</code> <p>Initial binary state of shape (width,).</p> required <code>rule</code> <code>ndarray</code> <p>Lookup table from <code>eca_rule_lkt</code>.</p> required <code>T</code> <code>int</code> <p>Number of update steps.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition (\"periodic\", \"fixed_zero\", \"fixed_one\", \"mirror\", or \"random\").</p> required <code>rng</code> <p>Optional random generator for \"random\" boundary.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: State history of shape (T + 1, width).</p>"},{"location":"api/#computingMicrobiome.eca.eca_step","title":"<code>eca_step(x, rule, boundary, rng=None)</code>","text":"<p>Advance one step of an elementary cellular automaton.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Current binary state of shape (width,).</p> required <code>rule</code> <code>ndarray</code> <p>Lookup table from <code>eca_rule_lkt</code>.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition (\"periodic\", \"fixed_zero\", \"fixed_one\", \"mirror\", or \"random\").</p> required <code>rng</code> <p>Optional random generator for \"random\" boundary.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Next state of shape (width,) with dtype int8.</p>"},{"location":"api/#models","title":"Models","text":"<p>               Bases: <code>BaseEstimator</code>, <code>ClassifierMixin</code></p> <p>Memory-only task for k-bit recall using an ECA reservoir.</p> <p>Parameters:</p> Name Type Description Default <code>bits</code> <code>int</code> <p>Number of bits to store and recall.</p> required <code>rule_number</code> <code>int</code> <p>ECA rule number (0-255).</p> required <code>width</code> <code>int</code> <p>Number of cells in the automaton.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition (\"periodic\", \"fixed_zero\", \"fixed_one\", \"mirror\", or \"random\").</p> required <code>recurrence</code> <code>int</code> <p>Number of input segments for injection.</p> required <code>itr</code> <code>int</code> <p>Number of iterations between ticks.</p> required <code>d_period</code> <code>int</code> <p>Delay between input and recall window.</p> required <code>seed</code> <code>int</code> <p>RNG seed for dataset generation and sampling.</p> <code>0</code> <code>readout_kind</code> <code>str</code> <p>\"svm\" or \"evo\".</p> <code>'svm'</code> <code>readout_config</code> <code>dict | None</code> <p>Optional configuration for the readout.</p> <code>None</code> <p>               Bases: <code>BaseEstimator</code>, <code>ClassifierMixin</code></p> <p>Compound opcode classifier with two 4-bit opcodes and operands.</p> <p>Each opcode encodes the truth table for f(x, y) with ordering: (x, y) = 00, 01, 10, 11. The first opcode is applied to (a, b), and its output is then combined with c using the second opcode.</p> <p>Parameters:</p> Name Type Description Default <code>rule_number</code> <code>int</code> <p>ECA rule number (0-255).</p> required <code>width</code> <code>int</code> <p>Number of cells in the automaton.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition (\"periodic\", \"fixed_zero\", \"fixed_one\", \"mirror\", or \"random\").</p> required <code>recurrence</code> <code>int</code> <p>Number of input segments for injection.</p> required <code>itr</code> <code>int</code> <p>Number of iterations between ticks.</p> required <code>d_period</code> <code>int</code> <p>Delay between input and output window.</p> required <code>repeats</code> <code>int</code> <p>Number of episode repeats per sample.</p> <code>1</code> <code>feature_mode</code> <code>str</code> <p>Feature extraction mode (\"cue_tick\" or \"window\").</p> <code>'cue_tick'</code> <code>output_window</code> <code>int</code> <p>Output window length when using windowed features.</p> <code>2</code> <code>seed</code> <code>int</code> <p>RNG seed for dataset generation and sampling.</p> <code>0</code> <code>readout_kind</code> <code>str</code> <p>\"svm\" or \"evo\".</p> <code>'svm'</code> <code>readout_config</code> <code>dict | None</code> <p>Optional configuration for the readout.</p> <code>None</code> <p>               Bases: <code>BaseEstimator</code>, <code>ClassifierMixin</code></p> <p>Programmable logic gate with a 3-bit opcode and 2 operand bits.</p> <p>Opcode bits are MSB-first and select one of 8 operations:</p> <ul> <li>000 AND</li> <li>001 OR</li> <li>010 XOR</li> <li>011 NAND</li> <li>100 NOR</li> <li>101 XNOR</li> <li>110 A</li> <li>111 B</li> </ul> <p>Parameters:</p> Name Type Description Default <code>rule_number</code> <code>int</code> <p>ECA rule number (0-255).</p> required <code>width</code> <code>int</code> <p>Number of cells in the automaton.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition (\"periodic\", \"fixed_zero\", \"fixed_one\", \"mirror\", or \"random\").</p> required <code>recurrence</code> <code>int</code> <p>Number of input segments for injection.</p> required <code>itr</code> <code>int</code> <p>Number of iterations between ticks.</p> required <code>d_period</code> <code>int</code> <p>Delay between input and output window.</p> required <code>repeats</code> <code>int</code> <p>Number of episode repeats per sample.</p> <code>1</code> <code>feature_mode</code> <code>str</code> <p>Feature extraction mode (\"cue_tick\" or \"window\").</p> <code>'cue_tick'</code> <code>output_window</code> <code>int</code> <p>Output window length when using windowed features.</p> <code>2</code> <code>seed</code> <code>int</code> <p>RNG seed for dataset generation and sampling.</p> <code>0</code> <code>readout_kind</code> <code>str</code> <p>\"svm\" or \"evo\".</p> <code>'svm'</code> <code>readout_config</code> <code>dict | None</code> <p>Optional configuration for the readout.</p> <code>None</code> Example <p>alu = KOpcodeLogic(110, 256, \"periodic\", 8, 8, 20).fit() alu.predict([[0, 0, 0, 1, 1]]).tolist() [1]</p> <p>               Bases: <code>BaseEstimator</code>, <code>ClassifierMixin</code></p> <p>Programmable logic gate with a 4-bit opcode and 2 operand bits.</p> <p>The opcode encodes the truth table for f(a, b) with ordering: (a, b) = 00, 01, 10, 11, where op0 is output for 00 and op3 for 11.</p> <p>Parameters:</p> Name Type Description Default <code>rule_number</code> <code>int</code> <p>ECA rule number (0-255).</p> required <code>width</code> <code>int</code> <p>Number of cells in the automaton.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition (\"periodic\", \"fixed_zero\", \"fixed_one\", \"mirror\", or \"random\").</p> required <code>recurrence</code> <code>int</code> <p>Number of input segments for injection.</p> required <code>itr</code> <code>int</code> <p>Number of iterations between ticks.</p> required <code>d_period</code> <code>int</code> <p>Delay between input and output window.</p> required <code>repeats</code> <code>int</code> <p>Number of episode repeats per sample.</p> <code>1</code> <code>feature_mode</code> <code>str</code> <p>Feature extraction mode (\"cue_tick\" or \"window\").</p> <code>'cue_tick'</code> <code>output_window</code> <code>int</code> <p>Output window length when using windowed features.</p> <code>2</code> <code>seed</code> <code>int</code> <p>RNG seed for dataset generation and sampling.</p> <code>0</code> <code>readout_kind</code> <code>str</code> <p>\"svm\" or \"evo\".</p> <code>'svm'</code> <code>readout_config</code> <code>dict | None</code> <p>Optional configuration for the readout.</p> <code>None</code> <p>               Bases: <code>BaseEstimator</code>, <code>ClassifierMixin</code></p> <p>Serial adder classifier that predicts each output bit at cue ticks.</p> <p>Inputs can be integers or bitstrings of length <code>bits</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rule_number</code> <code>int</code> <p>ECA rule number (0-255).</p> required <code>width</code> <code>int</code> <p>Number of cells in the automaton.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition (\"periodic\", \"fixed_zero\", \"fixed_one\", \"mirror\", or \"random\").</p> required <code>recurrence</code> <code>int</code> <p>Number of input segments for injection.</p> required <code>itr</code> <code>int</code> <p>Number of iterations between ticks.</p> required <code>d_period</code> <code>int</code> <p>Delay between input and output window.</p> required <code>bits</code> <code>int</code> <p>Bit-width of the adder.</p> <code>8</code> <code>n_train</code> <code>int</code> <p>Number of training samples.</p> <code>500</code> <code>seed</code> <code>int</code> <p>RNG seed for dataset generation and sampling.</p> <code>0</code> <code>readout_kind</code> <code>str</code> <p>\"svm\" or \"evo\".</p> <code>'svm'</code> <code>readout_config</code> <code>dict | None</code> <p>Optional configuration for the readout.</p> <code>None</code> <p>               Bases: <code>BaseEstimator</code>, <code>ClassifierMixin</code></p> <p>k-bit parity (XOR) classifier driven through an ECA reservoir.</p> Label definition <p>y = 1 if an odd number of input bits are 1, else 0.</p> <p>Parameters:</p> Name Type Description Default <code>bits</code> <code>int</code> <p>Number of input bits.</p> required <code>rule_number</code> <code>int</code> <p>ECA rule number (0-255).</p> required <code>width</code> <code>int</code> <p>Number of cells in the automaton.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition (\"periodic\", \"fixed_zero\", \"fixed_one\", \"mirror\", or \"random\").</p> required <code>recurrence</code> <code>int</code> <p>Number of input segments for injection.</p> required <code>itr</code> <code>int</code> <p>Number of iterations between ticks.</p> required <code>d_period</code> <code>int</code> <p>Delay between input and output window.</p> required <code>injection_interval</code> <code>int</code> <p>Spacing between injected bits (in ticks).</p> <code>0</code> <code>injection_repetitions</code> <code>int</code> <p>Repeat count of input injection sequence.</p> <code>1</code> <code>seed</code> <code>int</code> <p>RNG seed for dataset generation and sampling.</p> <code>0</code> <code>readout_kind</code> <code>str</code> <p>\"svm\" or \"evo\".</p> <code>'svm'</code> <code>readout_config</code> <code>dict | None</code> <p>Optional configuration for the readout.</p> <code>None</code>"},{"location":"api/#computingMicrobiome.models.k_bit_memory.KBitMemory.fit","title":"<code>fit(X=None, y=None)</code>","text":"<p>Fit the linear readout using the memory benchmark dataset.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <p>Ignored (present for sklearn API compatibility).</p> <code>None</code> <code>y</code> <p>Ignored (present for sklearn API compatibility).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>KBitMemory</code> <p>Fitted estimator.</p>"},{"location":"api/#computingMicrobiome.models.k_bit_memory.KBitMemory.predict","title":"<code>predict(X)</code>","text":"<p>Predict recalled bits for a batch of inputs.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <p>Array-like of shape (n_samples, n_bits) with input bit vectors.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Predicted bit vectors of shape (n_samples, bits).</p>"},{"location":"api/#computingMicrobiome.models.k_compound_opcode.KCompoundOpcode.fit","title":"<code>fit(X=None, y=None)</code>","text":"<p>Fit the classifier using the full 2048-case dataset.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <p>Ignored (present for sklearn API compatibility).</p> <code>None</code> <code>y</code> <p>Ignored (present for sklearn API compatibility).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>KCompoundOpcode</code> <p>Fitted estimator.</p>"},{"location":"api/#computingMicrobiome.models.k_compound_opcode.KCompoundOpcode.predict","title":"<code>predict(X)</code>","text":"<p>Predict compound opcode outputs.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <p>Array-like of shape (n_samples, 11) with [op1_3, op1_2, op1_1, op1_0, a, b, op2_3, op2_2, op2_1, op2_0, c].</p> required <p>Returns:</p> Type Description <p>np.ndarray: Predicted outputs of shape (n_samples,).</p>"},{"location":"api/#computingMicrobiome.models.k_opcode_logic.KOpcodeLogic.fit","title":"<code>fit(X=None, y=None)</code>","text":"<p>Fit the classifier using the full 32-case truth table.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <p>Ignored (present for sklearn API compatibility).</p> <code>None</code> <code>y</code> <p>Ignored (present for sklearn API compatibility).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>KOpcodeLogic</code> <p>Fitted estimator.</p>"},{"location":"api/#computingMicrobiome.models.k_opcode_logic.KOpcodeLogic.predict","title":"<code>predict(X)</code>","text":"<p>Predict logic outputs for opcode/operand inputs.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <p>Array-like of shape (n_samples, 5) with [op2, op1, op0, a, b] per row.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Predicted outputs of shape (n_samples,).</p>"},{"location":"api/#computingMicrobiome.models.k_opcode_logic16.KOpcodeLogic16.fit","title":"<code>fit(X=None, y=None)</code>","text":"<p>Fit the classifier using the full 64-case truth table.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <p>Ignored (present for sklearn API compatibility).</p> <code>None</code> <code>y</code> <p>Ignored (present for sklearn API compatibility).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>KOpcodeLogic16</code> <p>Fitted estimator.</p>"},{"location":"api/#computingMicrobiome.models.k_opcode_logic16.KOpcodeLogic16.predict","title":"<code>predict(X)</code>","text":"<p>Predict logic outputs for opcode/operand inputs.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <p>Array-like of shape (n_samples, 6) with [op3, op2, op1, op0, a, b] per row.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Predicted outputs of shape (n_samples,).</p>"},{"location":"api/#computingMicrobiome.models.k_serial_adder.KSerialAdder.fit","title":"<code>fit(X=None, y=None)</code>","text":"<p>Fit the classifier using randomly sampled training pairs.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <p>Ignored (present for sklearn API compatibility).</p> <code>None</code> <code>y</code> <p>Ignored (present for sklearn API compatibility).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>KSerialAdder</code> <p>Fitted estimator.</p>"},{"location":"api/#computingMicrobiome.models.k_serial_adder.KSerialAdder.predict","title":"<code>predict(A, B=None)</code>","text":"<p>Predict summed bits for pairs of inputs.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <p>Sequence of integers or bitstrings, or array of shape (n, 2).</p> required <code>B</code> <p>Optional sequence of integers or bitstrings (paired with A).</p> <code>None</code> <p>Returns:</p> Type Description <p>np.ndarray: Predicted sum bits of shape (n_samples, bits).</p>"},{"location":"api/#computingMicrobiome.models.k_xor.KXOR.fit","title":"<code>fit(X=None, y=None)</code>","text":"<p>Fit the classifier using the full truth table.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <p>Ignored (present for sklearn API compatibility).</p> <code>None</code> <code>y</code> <p>Ignored (present for sklearn API compatibility).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>KXOR</code> <p>Fitted estimator.</p>"},{"location":"api/#computingMicrobiome.models.k_xor.KXOR.predict","title":"<code>predict(X)</code>","text":"<p>Predict parity for a batch of input bit vectors.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <p>Array-like of shape (n_samples, bits).</p> required <p>Returns:</p> Type Description <p>np.ndarray: Predicted parity values of shape (n_samples,).</p>"},{"location":"api/#benchmarks","title":"Benchmarks","text":"<p>K-bit memory benchmark on elementary cellular automata.</p> <p>This module builds input/output streams, injects them into an ECA, and trains a linear readout on the output window to assess memory.</p> <p>Programmable-logic benchmark for ECA reservoirs.</p> Task <ul> <li>3-bit opcode selects a Boolean operation to apply to operands (a, b).</li> <li>Inputs are delivered as tagged packets using one-hot tag channels + value channels.</li> <li>The reservoir is driven deterministically (no randomness required beyond choosing injection sites).</li> <li>A linear readout (e.g., SVM) is trained to predict the 1-bit gate output at the cue.</li> </ul> <p>Packet encoding (one input event = one tick in the input-stream):   - Exactly one TAG_ channel is 1, indicating which field is being written.   - Exactly one VAL_ channel is 1, indicating the bit value (0 or 1).   - DIST channel is 1 on most ticks, and turned off at the CUE tick.   - CUE channel is 1 only at the cue tick.</p> <p>Default operations (opcode in MSB-first order op2 op1 op0):   000 AND   001 OR   010 XOR   011 NAND   100 NOR   101 XNOR   110 A   111 B</p> <p>Programmable-logic benchmark for ECA reservoirs (4-bit opcode).</p> Task <ul> <li>4-bit opcode selects a Boolean operation to apply to operands (a, b).</li> <li>Inputs are delivered as tagged packets using one-hot tag channels + value channels.</li> <li>The reservoir is driven deterministically (no randomness required beyond choosing injection sites).</li> <li>A linear readout (e.g., SVM) is trained to predict the 1-bit gate output at the cue.</li> </ul> <p>Packet encoding (one input event = one tick in the input-stream):   - Exactly one TAG_ channel is 1, indicating which field is being written.   - Exactly one VAL_ channel is 1, indicating the bit value (0 or 1).   - DIST channel is 1 on most ticks, and turned off at the CUE tick.   - CUE channel is 1 only at the cue tick.</p> Opcode definition <ul> <li>Bits are MSB-first [op3, op2, op1, op0].</li> <li>The opcode encodes the full truth table for f(a, b) with ordering:       (a,b) = 00, 01, 10, 11   op0 is the output for 00, op1 for 01, op2 for 10, op3 for 11.</li> </ul> <p>Compound-opcode benchmark for ECA reservoirs.</p> Task <ul> <li>Packet 1: 4-bit opcode op1 + operands a,b</li> <li>Packet 2: 4-bit opcode op2 + operand c</li> <li>Label:       y1 = f_op1(a,b)       y  = f_op2(y1,c)</li> </ul> Opcode definition <ul> <li>Bits are MSB-first [op3, op2, op1, op0].</li> <li>The opcode encodes the full truth table for f(x, y) with ordering:       (x,y) = 00, 01, 10, 11   op0 is the output for 00, op1 for 01, op2 for 10, op3 for 11.</li> </ul> <p>Serial adder benchmark for ECA reservoirs.</p> Task <ul> <li>Stream bits of two N-bit integers A and B from LSB to MSB.</li> <li>Maintain reservoir state across bits to preserve carry.</li> <li>Label for bit i is the i-th bit of (A + B).</li> </ul>"},{"location":"api/#computingMicrobiome.benchmarks.k_bit_memory_bm.Readout","title":"<code>Readout</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Minimal interface for readout models used in benchmarks.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_bit_memory_bm.build_dataset_output_window_only","title":"<code>build_dataset_output_window_only(bits, rule_number, width, boundary, recurrence, itr, d_period, seed=0)</code>","text":"<p>Build a dataset using only the output window.</p> <p>Parameters:</p> Name Type Description Default <code>bits</code> <code>int</code> <p>Number of bits to store/recall.</p> required <code>rule_number</code> <code>int</code> <p>ECA rule number (0-255).</p> required <code>width</code> <code>int</code> <p>Number of cells in the automaton.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition.</p> required <code>recurrence</code> <code>int</code> <p>Number of input segments for injection.</p> required <code>itr</code> <code>int</code> <p>Number of iterations between ticks.</p> required <code>d_period</code> <code>int</code> <p>Delay period between input and recall.</p> required <code>seed</code> <code>int</code> <p>RNG seed.</p> <code>0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Tuple[np.ndarray, np.ndarray, np.ndarray]: Feature matrix, labels,</p> <code>ndarray</code> <p>and input locations.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_bit_memory_bm.create_input_locations","title":"<code>create_input_locations(width, recurrence, input_channels, rng)</code>","text":"<p>Sample injection sites across the automaton width.</p> <p>The width is partitioned into <code>recurrence</code> segments and <code>input_channels</code> positions are sampled without replacement in each segment.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Total number of cells.</p> required <code>recurrence</code> <code>int</code> <p>Number of segments to partition the width into.</p> required <code>input_channels</code> <code>int</code> <p>Number of channels to inject per segment.</p> required <code>rng</code> <code>Generator</code> <p>NumPy random generator for sampling.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Integer array of length <code>recurrence * input_channels</code>.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_bit_memory_bm.create_input_streams","title":"<code>create_input_streams(bits_arr, d_period)</code>","text":"<p>Create input streams for the memory task.</p> <p>Parameters:</p> Name Type Description Default <code>bits_arr</code> <code>ndarray</code> <p>Bit vector of shape (bits,).</p> required <code>d_period</code> <code>int</code> <p>Delay period between input and recall window.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Input streams of shape (L, 4) where</p> <code>ndarray</code> <p>L = d_period + 2 * bits.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_bit_memory_bm.create_output_streams","title":"<code>create_output_streams(bits_arr, d_period)</code>","text":"<p>Create output streams for the memory task.</p> <p>Parameters:</p> Name Type Description Default <code>bits_arr</code> <code>ndarray</code> <p>Bit vector of shape (bits,).</p> required <code>d_period</code> <code>int</code> <p>Delay period between input and recall window.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Output streams of shape (L, 3) where</p> <code>ndarray</code> <p>L = d_period + 2 * bits.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_bit_memory_bm.eca_rule_lkt","title":"<code>eca_rule_lkt(rule_number)</code>","text":"<p>Generate an ECA rule lookup table.</p> <p>Parameters:</p> Name Type Description Default <code>rule_number</code> <code>int</code> <p>Integer in [0, 255] specifying the rule.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Lookup table of shape (8,) with dtype int8.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_bit_memory_bm.eca_step","title":"<code>eca_step(x, rule, boundary, rng=None)</code>","text":"<p>Advance one step of an elementary cellular automaton.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Current binary state of shape (width,).</p> required <code>rule</code> <code>ndarray</code> <p>Lookup table from <code>eca_rule_lkt</code>.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition (\"periodic\", \"fixed_zero\", \"fixed_one\", \"mirror\", or \"random\").</p> required <code>rng</code> <p>Optional random generator for \"random\" boundary.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Next state of shape (width,) with dtype int8.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_bit_memory_bm.evaluate_memory_trials","title":"<code>evaluate_memory_trials(reg, bits, rule_number, width, boundary, recurrence, itr, d_period, input_locations, n_trials=100, seed_trials=0, resample_input_locations=False)</code>","text":"<p>Evaluate recall correctness across randomized trials.</p> <p>Parameters:</p> Name Type Description Default <code>reg</code> <code>Readout</code> <p>Trained readout model.</p> required <code>bits</code> <code>int</code> <p>Number of bits.</p> required <code>rule_number</code> <code>int</code> <p>ECA rule number (0-255).</p> required <code>width</code> <code>int</code> <p>Number of cells in the automaton.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition.</p> required <code>recurrence</code> <code>int</code> <p>Number of input segments for injection.</p> required <code>itr</code> <code>int</code> <p>Number of iterations between ticks.</p> required <code>d_period</code> <code>int</code> <p>Delay period between input and recall.</p> required <code>input_locations</code> <code>ndarray</code> <p>Injection locations array.</p> required <code>n_trials</code> <code>int</code> <p>Number of random trials.</p> <code>100</code> <code>seed_trials</code> <code>int</code> <p>RNG seed for trials.</p> <code>0</code> <code>resample_input_locations</code> <code>bool</code> <p>If True, resample locations per trial.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Correctness matrix of shape (n_trials, bits) with values</p> <code>ndarray</code> <p>in {-1, 1}.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_bit_memory_bm.flatten_history","title":"<code>flatten_history(history_list_of_arrays)</code>","text":"<p>Concatenate a list of 1D arrays into a flat feature vector.</p> <p>Parameters:</p> Name Type Description Default <code>history_list_of_arrays</code> <code>List[ndarray]</code> <p>List of 1D arrays with matching shapes.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Flattened 1D vector formed by concatenation.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_bit_memory_bm.int_to_bits","title":"<code>int_to_bits(i, n_bits)</code>","text":"<p>Convert an integer to an MSB-first bit vector.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int</code> <p>Integer value to convert.</p> required <code>n_bits</code> <code>int</code> <p>Number of bits in the output vector.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Bit vector of shape (n_bits,) with dtype int8.</p> Example <p>int_to_bits(5, 3).tolist() [1, 0, 1]</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_bit_memory_bm.label_from_outputs","title":"<code>label_from_outputs(triple)</code>","text":"<p>Map [y0, y1, y2] to class 0/1/2.</p> <p>Parameters:</p> Name Type Description Default <code>triple</code> <code>ndarray</code> <p>Output triple of shape (3,).</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Class label (0, 1, or 2).</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_bit_memory_bm.make_readout","title":"<code>make_readout(kind='svm', config=None, *, rng=None)</code>","text":"<p>Create a readout by kind (svm, evo, meta_evo, moran, digital).</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_bit_memory_bm.run_episode_record","title":"<code>run_episode_record(bits_arr, rule_number, width, boundary, itr, d_period, rng, input_locations, reg=None, collect_states=True, x0_mode='zeros')</code>","text":"<p>Run one episode and optionally record states and predictions.</p> <p>Parameters:</p> Name Type Description Default <code>bits_arr</code> <code>ndarray</code> <p>Bit vector of shape (bits,).</p> required <code>rule_number</code> <code>int</code> <p>ECA rule number (0-255).</p> required <code>width</code> <code>int</code> <p>Number of cells in the automaton.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition.</p> required <code>itr</code> <code>int</code> <p>Number of iterations between ticks.</p> required <code>d_period</code> <code>int</code> <p>Delay period between input and recall.</p> required <code>rng</code> <code>Generator</code> <p>NumPy random generator.</p> required <code>input_locations</code> <code>ndarray</code> <p>Injection locations array.</p> required <code>reg</code> <code>Optional[Readout]</code> <p>Optional trained readout model for predictions.</p> <code>None</code> <code>collect_states</code> <code>bool</code> <p>Whether to store the full state history.</p> <code>True</code> <code>x0_mode</code> <code>str</code> <p>Initial state mode (\"zeros\" or \"random\").</p> <code>'zeros'</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Episode data including inputs, outputs, features, and predictions.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_bit_memory_bm.train_memory_readout","title":"<code>train_memory_readout(bits, rule_number, width, boundary, recurrence, itr, d_period, seed_train=0, readout_kind='svm', readout_config=None)</code>","text":"<p>Train a linear readout on the output-window dataset.</p> <p>Parameters:</p> Name Type Description Default <code>bits</code> <code>int</code> <p>Number of bits to store/recall.</p> required <code>rule_number</code> <code>int</code> <p>ECA rule number (0-255).</p> required <code>width</code> <code>int</code> <p>Number of cells in the automaton.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition.</p> required <code>recurrence</code> <code>int</code> <p>Number of input segments for injection.</p> required <code>itr</code> <code>int</code> <p>Number of iterations between ticks.</p> required <code>d_period</code> <code>int</code> <p>Delay period between input and recall.</p> required <code>seed_train</code> <code>int</code> <p>RNG seed for training data.</p> <code>0</code> <code>readout_kind</code> <code>str</code> <p>\"svm\" or \"evo\".</p> <code>'svm'</code> <code>readout_config</code> <code>Optional[dict]</code> <p>Optional configuration for the readout.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Readout, ndarray]</code> <p>Tuple[Readout, np.ndarray]: Trained classifier and input locations.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_bit_memory_bm.true_bits_from_episode_outputs","title":"<code>true_bits_from_episode_outputs(outputs_tick, bits)</code>","text":"<p>Decode target bits from the output streams.</p> <p>Parameters:</p> Name Type Description Default <code>outputs_tick</code> <code>ndarray</code> <p>Output streams of shape (L, 3).</p> required <code>bits</code> <code>int</code> <p>Number of bits encoded at the end of the episode.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Bit vector of shape (bits,) with values in {0, 1}.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.CUE","title":"<code>CUE = 8</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.DIST","title":"<code>DIST = 7</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.N_CHANNELS","title":"<code>N_CHANNELS = 9</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.TAG_A","title":"<code>TAG_A = 3</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.TAG_B","title":"<code>TAG_B = 4</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.TAG_CHANNELS","title":"<code>TAG_CHANNELS = [TAG_OP0, TAG_OP1, TAG_OP2, TAG_A, TAG_B]</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.TAG_OP0","title":"<code>TAG_OP0 = 0</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.TAG_OP1","title":"<code>TAG_OP1 = 1</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.TAG_OP2","title":"<code>TAG_OP2 = 2</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.VAL_0","title":"<code>VAL_0 = 5</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.VAL_1","title":"<code>VAL_1 = 6</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.VAL_CHANNELS","title":"<code>VAL_CHANNELS = [VAL_0, VAL_1]</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.Readout","title":"<code>Readout</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Minimal interface for readout models used in benchmarks.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.apply_opcode","title":"<code>apply_opcode(op_bits_msb_first, a, b)</code>","text":"<p>Apply the opcode-selected Boolean operation.</p> <p>Parameters:</p> Name Type Description Default <code>op_bits_msb_first</code> <code>ndarray</code> <p>Array of shape (3,) in order [op2, op1, op0].</p> required <code>a</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <code>b</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Result bit (0 or 1).</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.build_dataset_programmed_logic","title":"<code>build_dataset_programmed_logic(rule_number, width, boundary, recurrence, itr, d_period, repeats=1, feature_mode='cue_tick', output_window=2, seed=0, order=None)</code>","text":"<p>Build a dataset for the programmed-logic task.</p> <p>Parameters:</p> Name Type Description Default <code>rule_number</code> <code>int</code> <p>ECA rule number (0-255).</p> required <code>width</code> <code>int</code> <p>Number of cells in the automaton.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition.</p> required <code>recurrence</code> <code>int</code> <p>Number of input segments for injection.</p> required <code>itr</code> <code>int</code> <p>Number of iterations between ticks.</p> required <code>d_period</code> <code>int</code> <p>Distractor length in input ticks.</p> required <code>repeats</code> <code>int</code> <p>Number of times to repeat write packets.</p> <code>1</code> <code>feature_mode</code> <code>str</code> <p>\"cue_tick\" or \"output_window\".</p> <code>'cue_tick'</code> <code>output_window</code> <code>int</code> <p>Window length when feature_mode is \"output_window\".</p> <code>2</code> <code>seed</code> <code>int</code> <p>RNG seed for dataset generation.</p> <code>0</code> <code>order</code> <code>Optional[Sequence[str]]</code> <p>Optional packet field ordering.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Tuple[np.ndarray, np.ndarray, np.ndarray]: Feature matrix, labels,</p> <code>ndarray</code> <p>and input locations.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.build_tagged_stream","title":"<code>build_tagged_stream(op_bits_msb_first, a, b, d_period, repeats=1, order=None)</code>","text":"<p>Build the tagged input stream for a single episode.</p> <p>Parameters:</p> Name Type Description Default <code>op_bits_msb_first</code> <code>ndarray</code> <p>Array of shape (3,) in order [op2, op1, op0].</p> required <code>a</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <code>b</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <code>d_period</code> <code>int</code> <p>Distractor length in input ticks.</p> required <code>repeats</code> <code>int</code> <p>Number of times to repeat the write packets.</p> <code>1</code> <code>order</code> <code>Optional[Sequence[str]]</code> <p>Optional sequence of field names among {\"op0\", \"op1\", \"op2\", \"a\", \"b\"}. If None, uses [\"op0\", \"op1\", \"op2\", \"a\", \"b\"].</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Stream of shape (L, 9).</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.create_input_locations","title":"<code>create_input_locations(width, recurrence, input_channels, rng)</code>","text":"<p>Sample injection sites across the automaton width.</p> <p>The width is partitioned into <code>recurrence</code> segments and <code>input_channels</code> positions are sampled without replacement in each segment.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Total number of cells.</p> required <code>recurrence</code> <code>int</code> <p>Number of segments to partition the width into.</p> required <code>input_channels</code> <code>int</code> <p>Number of channels to inject per segment.</p> required <code>rng</code> <code>Generator</code> <p>NumPy random generator for sampling.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Integer array of length <code>recurrence * input_channels</code>.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.eca_rule_lkt","title":"<code>eca_rule_lkt(rule_number)</code>","text":"<p>Generate an ECA rule lookup table.</p> <p>Parameters:</p> Name Type Description Default <code>rule_number</code> <code>int</code> <p>Integer in [0, 255] specifying the rule.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Lookup table of shape (8,) with dtype int8.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.eca_step","title":"<code>eca_step(x, rule, boundary, rng=None)</code>","text":"<p>Advance one step of an elementary cellular automaton.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Current binary state of shape (width,).</p> required <code>rule</code> <code>ndarray</code> <p>Lookup table from <code>eca_rule_lkt</code>.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition (\"periodic\", \"fixed_zero\", \"fixed_one\", \"mirror\", or \"random\").</p> required <code>rng</code> <p>Optional random generator for \"random\" boundary.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Next state of shape (width,) with dtype int8.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.flatten_history","title":"<code>flatten_history(history_list_of_arrays)</code>","text":"<p>Concatenate a list of 1D arrays into a flat feature vector.</p> <p>Parameters:</p> Name Type Description Default <code>history_list_of_arrays</code> <code>List[ndarray]</code> <p>List of 1D arrays with matching shapes.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Flattened 1D vector formed by concatenation.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.make_packet","title":"<code>make_packet(tag_channel, value)</code>","text":"<p>Create a single tagged packet.</p> <p>Parameters:</p> Name Type Description Default <code>tag_channel</code> <code>int</code> <p>Tag channel index.</p> required <code>value</code> <code>int</code> <p>Bit value (0 or 1).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Packet of shape (9,) with dtype int8.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.make_readout","title":"<code>make_readout(kind='svm', config=None, *, rng=None)</code>","text":"<p>Create a readout by kind (svm, evo, meta_evo, moran, digital).</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.opcode_to_int","title":"<code>opcode_to_int(op_bits_msb_first)</code>","text":"<p>Convert MSB-first opcode bits to an integer in [0, 7].</p> <p>Parameters:</p> Name Type Description Default <code>op_bits_msb_first</code> <code>ndarray</code> <p>Array of shape (3,) in order [op2, op1, op0].</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Opcode integer in [0, 7].</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.run_episode_record_tagged","title":"<code>run_episode_record_tagged(op_bits_msb_first, a, b, rule_number, width, boundary, itr, d_period, rng, input_locations, repeats=1, order=None, reg=None, collect_states=True, x0_mode='zeros', feature_mode='cue_tick', output_window=2)</code>","text":"<p>Run one tagged-program episode and optionally score with a readout.</p> <p>Parameters:</p> Name Type Description Default <code>op_bits_msb_first</code> <code>ndarray</code> <p>Array of shape (3,) in order [op2, op1, op0].</p> required <code>a</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <code>b</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <code>rule_number</code> <code>int</code> <p>ECA rule number (0-255).</p> required <code>width</code> <code>int</code> <p>Number of cells in the automaton.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition.</p> required <code>itr</code> <code>int</code> <p>Number of iterations between ticks.</p> required <code>d_period</code> <code>int</code> <p>Distractor length in input ticks.</p> required <code>rng</code> <code>Generator</code> <p>NumPy random generator.</p> required <code>input_locations</code> <code>ndarray</code> <p>Injection locations array.</p> required <code>repeats</code> <code>int</code> <p>Number of times to repeat the write packets.</p> <code>1</code> <code>order</code> <code>Optional[Sequence[str]]</code> <p>Optional packet field ordering.</p> <code>None</code> <code>reg</code> <code>Optional[Readout]</code> <p>Optional trained readout model for predictions.</p> <code>None</code> <code>collect_states</code> <code>bool</code> <p>Whether to store the full state history.</p> <code>True</code> <code>x0_mode</code> <code>str</code> <p>Initial state mode (\"zeros\" or \"random\").</p> <code>'zeros'</code> <code>feature_mode</code> <code>str</code> <p>\"cue_tick\" or \"output_window\".</p> <code>'cue_tick'</code> <code>output_window</code> <code>int</code> <p>Window length when feature_mode is \"output_window\".</p> <code>2</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Episode data including inputs, features, predictions, and states.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic_bm.train_programmed_logic_readout","title":"<code>train_programmed_logic_readout(rule_number, width, boundary, recurrence, itr, d_period, repeats=1, feature_mode='cue_tick', output_window=2, seed_train=0, order=None, readout_kind='svm', readout_config=None)</code>","text":"<p>Train a linear readout for the programmed-logic task.</p> <p>Parameters:</p> Name Type Description Default <code>rule_number</code> <code>int</code> <p>ECA rule number (0-255).</p> required <code>width</code> <code>int</code> <p>Number of cells in the automaton.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition.</p> required <code>recurrence</code> <code>int</code> <p>Number of input segments for injection.</p> required <code>itr</code> <code>int</code> <p>Number of iterations between ticks.</p> required <code>d_period</code> <code>int</code> <p>Distractor length in input ticks.</p> required <code>repeats</code> <code>int</code> <p>Number of times to repeat write packets.</p> <code>1</code> <code>feature_mode</code> <code>str</code> <p>\"cue_tick\" or \"output_window\".</p> <code>'cue_tick'</code> <code>output_window</code> <code>int</code> <p>Window length when feature_mode is \"output_window\".</p> <code>2</code> <code>seed_train</code> <code>int</code> <p>RNG seed for training data.</p> <code>0</code> <code>order</code> <code>Optional[Sequence[str]]</code> <p>Optional packet field ordering.</p> <code>None</code> <code>readout_kind</code> <code>str</code> <p>\"svm\" or \"evo\".</p> <code>'svm'</code> <code>readout_config</code> <code>Optional[dict]</code> <p>Optional configuration for the readout.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Readout, ndarray]</code> <p>Tuple[Readout, np.ndarray]: Trained classifier and input locations.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.CUE","title":"<code>CUE = 9</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.DIST","title":"<code>DIST = 8</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.N_CHANNELS","title":"<code>N_CHANNELS = 10</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.TAG_A","title":"<code>TAG_A = 4</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.TAG_B","title":"<code>TAG_B = 5</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.TAG_CHANNELS","title":"<code>TAG_CHANNELS = [TAG_OP0, TAG_OP1, TAG_OP2, TAG_OP3, TAG_A, TAG_B]</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.TAG_OP0","title":"<code>TAG_OP0 = 0</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.TAG_OP1","title":"<code>TAG_OP1 = 1</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.TAG_OP2","title":"<code>TAG_OP2 = 2</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.TAG_OP3","title":"<code>TAG_OP3 = 3</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.VAL_0","title":"<code>VAL_0 = 6</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.VAL_1","title":"<code>VAL_1 = 7</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.VAL_CHANNELS","title":"<code>VAL_CHANNELS = [VAL_0, VAL_1]</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.Readout","title":"<code>Readout</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Minimal interface for readout models used in benchmarks.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.apply_opcode","title":"<code>apply_opcode(op_bits_msb_first, a, b)</code>","text":"<p>Apply the opcode-selected Boolean operation.</p> <p>Parameters:</p> Name Type Description Default <code>op_bits_msb_first</code> <code>ndarray</code> <p>Array of shape (4,) in order [op3, op2, op1, op0].</p> required <code>a</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <code>b</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Result bit (0 or 1).</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.build_dataset_programmed_logic","title":"<code>build_dataset_programmed_logic(rule_number, width, boundary, recurrence, itr, d_period, repeats=1, feature_mode='cue_tick', output_window=2, seed=0, order=None)</code>","text":"<p>Build a dataset for the programmed-logic task.</p> <p>Parameters:</p> Name Type Description Default <code>rule_number</code> <code>int</code> <p>ECA rule number (0-255).</p> required <code>width</code> <code>int</code> <p>Number of cells in the automaton.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition.</p> required <code>recurrence</code> <code>int</code> <p>Number of input segments for injection.</p> required <code>itr</code> <code>int</code> <p>Number of iterations between ticks.</p> required <code>d_period</code> <code>int</code> <p>Distractor length in input ticks.</p> required <code>repeats</code> <code>int</code> <p>Number of times to repeat write packets.</p> <code>1</code> <code>feature_mode</code> <code>str</code> <p>\"cue_tick\" or \"output_window\".</p> <code>'cue_tick'</code> <code>output_window</code> <code>int</code> <p>Window length when feature_mode is \"output_window\".</p> <code>2</code> <code>seed</code> <code>int</code> <p>RNG seed for dataset generation.</p> <code>0</code> <code>order</code> <code>Optional[Sequence[str]]</code> <p>Optional packet field ordering.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Tuple[np.ndarray, np.ndarray, np.ndarray]: Feature matrix, labels,</p> <code>ndarray</code> <p>and input locations.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.build_tagged_stream","title":"<code>build_tagged_stream(op_bits_msb_first, a, b, d_period, repeats=1, order=None)</code>","text":"<p>Build the tagged input stream for a single episode.</p> <p>Parameters:</p> Name Type Description Default <code>op_bits_msb_first</code> <code>ndarray</code> <p>Array of shape (4,) in order [op3, op2, op1, op0].</p> required <code>a</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <code>b</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <code>d_period</code> <code>int</code> <p>Distractor length in input ticks.</p> required <code>repeats</code> <code>int</code> <p>Number of times to repeat the write packets.</p> <code>1</code> <code>order</code> <code>Optional[Sequence[str]]</code> <p>Optional sequence of field names among {\"op0\", \"op1\", \"op2\", \"op3\", \"a\", \"b\"}. If None, uses [\"op0\", \"op1\", \"op2\", \"op3\", \"a\", \"b\"].</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Stream of shape (L, 10).</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.create_input_locations","title":"<code>create_input_locations(width, recurrence, input_channels, rng)</code>","text":"<p>Sample injection sites across the automaton width.</p> <p>The width is partitioned into <code>recurrence</code> segments and <code>input_channels</code> positions are sampled without replacement in each segment.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Total number of cells.</p> required <code>recurrence</code> <code>int</code> <p>Number of segments to partition the width into.</p> required <code>input_channels</code> <code>int</code> <p>Number of channels to inject per segment.</p> required <code>rng</code> <code>Generator</code> <p>NumPy random generator for sampling.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Integer array of length <code>recurrence * input_channels</code>.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.eca_rule_lkt","title":"<code>eca_rule_lkt(rule_number)</code>","text":"<p>Generate an ECA rule lookup table.</p> <p>Parameters:</p> Name Type Description Default <code>rule_number</code> <code>int</code> <p>Integer in [0, 255] specifying the rule.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Lookup table of shape (8,) with dtype int8.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.eca_step","title":"<code>eca_step(x, rule, boundary, rng=None)</code>","text":"<p>Advance one step of an elementary cellular automaton.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Current binary state of shape (width,).</p> required <code>rule</code> <code>ndarray</code> <p>Lookup table from <code>eca_rule_lkt</code>.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition (\"periodic\", \"fixed_zero\", \"fixed_one\", \"mirror\", or \"random\").</p> required <code>rng</code> <p>Optional random generator for \"random\" boundary.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Next state of shape (width,) with dtype int8.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.flatten_history","title":"<code>flatten_history(history_list_of_arrays)</code>","text":"<p>Concatenate a list of 1D arrays into a flat feature vector.</p> <p>Parameters:</p> Name Type Description Default <code>history_list_of_arrays</code> <code>List[ndarray]</code> <p>List of 1D arrays with matching shapes.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Flattened 1D vector formed by concatenation.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.make_packet","title":"<code>make_packet(tag_channel, value)</code>","text":"<p>Create a single tagged packet.</p> <p>Parameters:</p> Name Type Description Default <code>tag_channel</code> <code>int</code> <p>Tag channel index.</p> required <code>value</code> <code>int</code> <p>Bit value (0 or 1).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Packet of shape (10,) with dtype int8.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.make_readout","title":"<code>make_readout(kind='svm', config=None, *, rng=None)</code>","text":"<p>Create a readout by kind (svm, evo, meta_evo, moran, digital).</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.opcode_to_int","title":"<code>opcode_to_int(op_bits_msb_first)</code>","text":"<p>Convert MSB-first opcode bits to an integer in [0, 15].</p> <p>Parameters:</p> Name Type Description Default <code>op_bits_msb_first</code> <code>ndarray</code> <p>Array of shape (4,) in order [op3, op2, op1, op0].</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Opcode integer in [0, 15].</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.run_episode_record_tagged","title":"<code>run_episode_record_tagged(op_bits_msb_first, a, b, rule_number, width, boundary, itr, d_period, rng, input_locations, repeats=1, order=None, reg=None, collect_states=True, x0_mode='zeros', feature_mode='cue_tick', output_window=2)</code>","text":"<p>Run one tagged-program episode and optionally score with a readout.</p> <p>Parameters:</p> Name Type Description Default <code>op_bits_msb_first</code> <code>ndarray</code> <p>Array of shape (4,) in order [op3, op2, op1, op0].</p> required <code>a</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <code>b</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <code>rule_number</code> <code>int</code> <p>ECA rule number (0-255).</p> required <code>width</code> <code>int</code> <p>Number of cells in the automaton.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition.</p> required <code>itr</code> <code>int</code> <p>Number of iterations between ticks.</p> required <code>d_period</code> <code>int</code> <p>Distractor length in input ticks.</p> required <code>rng</code> <code>Generator</code> <p>NumPy random generator.</p> required <code>input_locations</code> <code>ndarray</code> <p>Injection locations array.</p> required <code>repeats</code> <code>int</code> <p>Number of times to repeat the write packets.</p> <code>1</code> <code>order</code> <code>Optional[Sequence[str]]</code> <p>Optional packet field ordering.</p> <code>None</code> <code>reg</code> <code>Optional[Readout]</code> <p>Optional trained readout model for predictions.</p> <code>None</code> <code>collect_states</code> <code>bool</code> <p>Whether to store the full state history.</p> <code>True</code> <code>x0_mode</code> <code>str</code> <p>Initial state mode (\"zeros\" or \"random\").</p> <code>'zeros'</code> <code>feature_mode</code> <code>str</code> <p>\"cue_tick\" or \"output_window\".</p> <code>'cue_tick'</code> <code>output_window</code> <code>int</code> <p>Window length when feature_mode is \"output_window\".</p> <code>2</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Episode data including inputs, features, predictions, and states.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_opcode_logic16_bm.train_programmed_logic_readout","title":"<code>train_programmed_logic_readout(rule_number, width, boundary, recurrence, itr, d_period, repeats=1, feature_mode='cue_tick', output_window=2, seed_train=0, order=None, readout_kind='svm', readout_config=None)</code>","text":"<p>Train a linear readout for the programmed-logic task.</p> <p>Parameters:</p> Name Type Description Default <code>rule_number</code> <code>int</code> <p>ECA rule number (0-255).</p> required <code>width</code> <code>int</code> <p>Number of cells in the automaton.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition.</p> required <code>recurrence</code> <code>int</code> <p>Number of input segments for injection.</p> required <code>itr</code> <code>int</code> <p>Number of iterations between ticks.</p> required <code>d_period</code> <code>int</code> <p>Distractor length in input ticks.</p> required <code>repeats</code> <code>int</code> <p>Number of times to repeat write packets.</p> <code>1</code> <code>feature_mode</code> <code>str</code> <p>\"cue_tick\" or \"output_window\".</p> <code>'cue_tick'</code> <code>output_window</code> <code>int</code> <p>Window length when feature_mode is \"output_window\".</p> <code>2</code> <code>seed_train</code> <code>int</code> <p>RNG seed for training data.</p> <code>0</code> <code>order</code> <code>Optional[Sequence[str]]</code> <p>Optional packet field ordering.</p> <code>None</code> <code>readout_kind</code> <code>str</code> <p>\"svm\" or \"evo\".</p> <code>'svm'</code> <code>readout_config</code> <code>Optional[dict]</code> <p>Optional configuration for the readout.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Readout, ndarray]</code> <p>Tuple[Readout, np.ndarray]: Trained classifier and input locations.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.CUE","title":"<code>CUE = 14</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.DIST","title":"<code>DIST = 13</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.N_CHANNELS","title":"<code>N_CHANNELS = 15</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.TAG_A","title":"<code>TAG_A = 4</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.TAG_B","title":"<code>TAG_B = 5</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.TAG_C","title":"<code>TAG_C = 10</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.TAG_CHANNELS","title":"<code>TAG_CHANNELS = [TAG_OP1_0, TAG_OP1_1, TAG_OP1_2, TAG_OP1_3, TAG_A, TAG_B, TAG_OP2_0, TAG_OP2_1, TAG_OP2_2, TAG_OP2_3, TAG_C]</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.TAG_OP1_0","title":"<code>TAG_OP1_0 = 0</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.TAG_OP1_1","title":"<code>TAG_OP1_1 = 1</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.TAG_OP1_2","title":"<code>TAG_OP1_2 = 2</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.TAG_OP1_3","title":"<code>TAG_OP1_3 = 3</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.TAG_OP2_0","title":"<code>TAG_OP2_0 = 6</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.TAG_OP2_1","title":"<code>TAG_OP2_1 = 7</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.TAG_OP2_2","title":"<code>TAG_OP2_2 = 8</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.TAG_OP2_3","title":"<code>TAG_OP2_3 = 9</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.VAL_0","title":"<code>VAL_0 = 11</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.VAL_1","title":"<code>VAL_1 = 12</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.VAL_CHANNELS","title":"<code>VAL_CHANNELS = [VAL_0, VAL_1]</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.Readout","title":"<code>Readout</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Minimal interface for readout models used in benchmarks.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.apply_compound_opcode","title":"<code>apply_compound_opcode(op1_bits_msb_first, a, b, op2_bits_msb_first, c)</code>","text":"<p>Compute compound output y = f_op2(f_op1(a, b), c).</p> <p>Parameters:</p> Name Type Description Default <code>op1_bits_msb_first</code> <code>ndarray</code> <p>Opcode bits for op1 (shape (4,)).</p> required <code>a</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <code>b</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <code>op2_bits_msb_first</code> <code>ndarray</code> <p>Opcode bits for op2 (shape (4,)).</p> required <code>c</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Result bit (0 or 1).</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.apply_opcode","title":"<code>apply_opcode(op_bits_msb_first, x, y)</code>","text":"<p>Apply the opcode-selected Boolean operation.</p> <p>Parameters:</p> Name Type Description Default <code>op_bits_msb_first</code> <code>ndarray</code> <p>Array of shape (4,) in order [op3, op2, op1, op0].</p> required <code>x</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <code>y</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Result bit (0 or 1).</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.build_dataset_compound_opcode","title":"<code>build_dataset_compound_opcode(rule_number, width, boundary, recurrence, itr, d_period, repeats=1, feature_mode='cue_tick', output_window=2, seed=0)</code>","text":"<p>Build a dataset for the compound-opcode task.</p> <p>Parameters:</p> Name Type Description Default <code>rule_number</code> <code>int</code> <p>ECA rule number (0-255).</p> required <code>width</code> <code>int</code> <p>Number of cells in the automaton.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition.</p> required <code>recurrence</code> <code>int</code> <p>Number of input segments for injection.</p> required <code>itr</code> <code>int</code> <p>Number of iterations between ticks.</p> required <code>d_period</code> <code>int</code> <p>Distractor length in input ticks.</p> required <code>repeats</code> <code>int</code> <p>Number of times to repeat write packets.</p> <code>1</code> <code>feature_mode</code> <code>str</code> <p>\"cue_tick\" or \"output_window\".</p> <code>'cue_tick'</code> <code>output_window</code> <code>int</code> <p>Window length when feature_mode is \"output_window\".</p> <code>2</code> <code>seed</code> <code>int</code> <p>RNG seed for dataset generation.</p> <code>0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Tuple[np.ndarray, np.ndarray, np.ndarray]: Feature matrix, labels,</p> <code>ndarray</code> <p>and input locations.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.build_tagged_stream","title":"<code>build_tagged_stream(op1_bits_msb_first, a, b, op2_bits_msb_first, c, d_period, repeats=1)</code>","text":"<p>Build the tagged input stream for a compound opcode episode.</p> <p>Parameters:</p> Name Type Description Default <code>op1_bits_msb_first</code> <code>ndarray</code> <p>Opcode bits for op1 (shape (4,)).</p> required <code>a</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <code>b</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <code>op2_bits_msb_first</code> <code>ndarray</code> <p>Opcode bits for op2 (shape (4,)).</p> required <code>c</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <code>d_period</code> <code>int</code> <p>Distractor length in input ticks.</p> required <code>repeats</code> <code>int</code> <p>Number of times to repeat the write packets.</p> <code>1</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Stream of shape (L, 15).</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.create_input_locations","title":"<code>create_input_locations(width, recurrence, input_channels, rng)</code>","text":"<p>Sample injection sites across the automaton width.</p> <p>The width is partitioned into <code>recurrence</code> segments and <code>input_channels</code> positions are sampled without replacement in each segment.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Total number of cells.</p> required <code>recurrence</code> <code>int</code> <p>Number of segments to partition the width into.</p> required <code>input_channels</code> <code>int</code> <p>Number of channels to inject per segment.</p> required <code>rng</code> <code>Generator</code> <p>NumPy random generator for sampling.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Integer array of length <code>recurrence * input_channels</code>.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.eca_rule_lkt","title":"<code>eca_rule_lkt(rule_number)</code>","text":"<p>Generate an ECA rule lookup table.</p> <p>Parameters:</p> Name Type Description Default <code>rule_number</code> <code>int</code> <p>Integer in [0, 255] specifying the rule.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Lookup table of shape (8,) with dtype int8.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.eca_step","title":"<code>eca_step(x, rule, boundary, rng=None)</code>","text":"<p>Advance one step of an elementary cellular automaton.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Current binary state of shape (width,).</p> required <code>rule</code> <code>ndarray</code> <p>Lookup table from <code>eca_rule_lkt</code>.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition (\"periodic\", \"fixed_zero\", \"fixed_one\", \"mirror\", or \"random\").</p> required <code>rng</code> <p>Optional random generator for \"random\" boundary.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Next state of shape (width,) with dtype int8.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.flatten_history","title":"<code>flatten_history(history_list_of_arrays)</code>","text":"<p>Concatenate a list of 1D arrays into a flat feature vector.</p> <p>Parameters:</p> Name Type Description Default <code>history_list_of_arrays</code> <code>List[ndarray]</code> <p>List of 1D arrays with matching shapes.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Flattened 1D vector formed by concatenation.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.make_packet","title":"<code>make_packet(tag_channel, value)</code>","text":"<p>Create a single tagged packet.</p> <p>Parameters:</p> Name Type Description Default <code>tag_channel</code> <code>int</code> <p>Tag channel index.</p> required <code>value</code> <code>int</code> <p>Bit value (0 or 1).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Packet of shape (15,) with dtype int8.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.make_readout","title":"<code>make_readout(kind='svm', config=None, *, rng=None)</code>","text":"<p>Create a readout by kind (svm, evo, meta_evo, moran, digital).</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.opcode_to_int","title":"<code>opcode_to_int(op_bits_msb_first)</code>","text":"<p>Convert MSB-first opcode bits to an integer in [0, 15].</p> <p>Parameters:</p> Name Type Description Default <code>op_bits_msb_first</code> <code>ndarray</code> <p>Array of shape (4,) in order [op3, op2, op1, op0].</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Opcode integer in [0, 15].</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.run_episode_record_tagged","title":"<code>run_episode_record_tagged(op1_bits_msb_first, a, b, op2_bits_msb_first, c, rule_number, width, boundary, itr, d_period, rng, input_locations, repeats=1, reg=None, collect_states=True, x0_mode='zeros', feature_mode='cue_tick', output_window=2)</code>","text":"<p>Run one compound-opcode episode and optionally score with a readout.</p> <p>Parameters:</p> Name Type Description Default <code>op1_bits_msb_first</code> <code>ndarray</code> <p>Opcode bits for op1 (shape (4,)).</p> required <code>a</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <code>b</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <code>op2_bits_msb_first</code> <code>ndarray</code> <p>Opcode bits for op2 (shape (4,)).</p> required <code>c</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <code>rule_number</code> <code>int</code> <p>ECA rule number (0-255).</p> required <code>width</code> <code>int</code> <p>Number of cells in the automaton.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition.</p> required <code>itr</code> <code>int</code> <p>Number of iterations between ticks.</p> required <code>d_period</code> <code>int</code> <p>Distractor length in input ticks.</p> required <code>rng</code> <code>Generator</code> <p>NumPy random generator.</p> required <code>input_locations</code> <code>ndarray</code> <p>Injection locations array.</p> required <code>repeats</code> <code>int</code> <p>Number of times to repeat the write packets.</p> <code>1</code> <code>reg</code> <code>Optional[Readout]</code> <p>Optional trained readout model for predictions.</p> <code>None</code> <code>collect_states</code> <code>bool</code> <p>Whether to store the full state history.</p> <code>True</code> <code>x0_mode</code> <code>str</code> <p>Initial state mode (\"zeros\" or \"random\").</p> <code>'zeros'</code> <code>feature_mode</code> <code>str</code> <p>\"cue_tick\" or \"output_window\".</p> <code>'cue_tick'</code> <code>output_window</code> <code>int</code> <p>Window length when feature_mode is \"output_window\".</p> <code>2</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Episode data including inputs, features, predictions, and states.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_compound_opcode_bm.train_compound_opcode_readout","title":"<code>train_compound_opcode_readout(rule_number, width, boundary, recurrence, itr, d_period, repeats=1, feature_mode='cue_tick', output_window=2, seed_train=0, readout_kind='svm', readout_config=None)</code>","text":"<p>Train a linear readout for the compound-opcode task.</p> <p>Parameters:</p> Name Type Description Default <code>rule_number</code> <code>int</code> <p>ECA rule number (0-255).</p> required <code>width</code> <code>int</code> <p>Number of cells in the automaton.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition.</p> required <code>recurrence</code> <code>int</code> <p>Number of input segments for injection.</p> required <code>itr</code> <code>int</code> <p>Number of iterations between ticks.</p> required <code>d_period</code> <code>int</code> <p>Distractor length in input ticks.</p> required <code>repeats</code> <code>int</code> <p>Number of times to repeat write packets.</p> <code>1</code> <code>feature_mode</code> <code>str</code> <p>\"cue_tick\" or \"output_window\".</p> <code>'cue_tick'</code> <code>output_window</code> <code>int</code> <p>Window length when feature_mode is \"output_window\".</p> <code>2</code> <code>seed_train</code> <code>int</code> <p>RNG seed for training data.</p> <code>0</code> <code>readout_kind</code> <code>str</code> <p>\"svm\" or \"evo\".</p> <code>'svm'</code> <code>readout_config</code> <code>Optional[dict]</code> <p>Optional configuration for the readout.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Readout, ndarray]</code> <p>Tuple[Readout, np.ndarray]: Trained classifier and input locations.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_serial_adder_bm.CUE","title":"<code>CUE = 4</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_serial_adder_bm.DIST","title":"<code>DIST = 3</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_serial_adder_bm.N_CHANNELS","title":"<code>N_CHANNELS = 5</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_serial_adder_bm.TAG_A","title":"<code>TAG_A = 0</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_serial_adder_bm.TAG_B","title":"<code>TAG_B = 1</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_serial_adder_bm.VAL","title":"<code>VAL = 2</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.benchmarks.k_serial_adder_bm.Readout","title":"<code>Readout</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Minimal interface for readout models used in benchmarks.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_serial_adder_bm.build_dataset_serial_adder","title":"<code>build_dataset_serial_adder(bits, n_samples, rule_number, width, boundary, recurrence, itr, d_period, seed=0)</code>","text":"<p>Build a dataset from random N-bit addition problems.</p> <p>Parameters:</p> Name Type Description Default <code>bits</code> <code>int</code> <p>Bit-width of the adder.</p> required <code>n_samples</code> <code>int</code> <p>Number of samples to generate.</p> required <code>rule_number</code> <code>int</code> <p>ECA rule number (0-255).</p> required <code>width</code> <code>int</code> <p>Number of cells in the automaton.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition.</p> required <code>recurrence</code> <code>int</code> <p>Number of input segments for injection.</p> required <code>itr</code> <code>int</code> <p>Number of iterations between ticks.</p> required <code>d_period</code> <code>int</code> <p>Distractor length in input ticks.</p> required <code>seed</code> <code>int</code> <p>RNG seed for dataset generation.</p> <code>0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Tuple[np.ndarray, np.ndarray, np.ndarray]: Feature matrix, labels,</p> <code>ndarray</code> <p>and input locations.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_serial_adder_bm.build_tagged_stream_serial_adder","title":"<code>build_tagged_stream_serial_adder(a_bits_lsb, b_bits_lsb, d_period)</code>","text":"<p>Build input stream and cue indices for serial addition.</p> <p>Parameters:</p> Name Type Description Default <code>a_bits_lsb</code> <code>ndarray</code> <p>LSB-first bits for A.</p> required <code>b_bits_lsb</code> <code>ndarray</code> <p>LSB-first bits for B.</p> required <code>d_period</code> <code>int</code> <p>Distractor length in input ticks.</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray]: Stream of shape (L, 5) and cue indices.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_serial_adder_bm.create_input_locations","title":"<code>create_input_locations(width, recurrence, input_channels, rng)</code>","text":"<p>Sample injection sites across the automaton width.</p> <p>The width is partitioned into <code>recurrence</code> segments and <code>input_channels</code> positions are sampled without replacement in each segment.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Total number of cells.</p> required <code>recurrence</code> <code>int</code> <p>Number of segments to partition the width into.</p> required <code>input_channels</code> <code>int</code> <p>Number of channels to inject per segment.</p> required <code>rng</code> <code>Generator</code> <p>NumPy random generator for sampling.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Integer array of length <code>recurrence * input_channels</code>.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_serial_adder_bm.eca_rule_lkt","title":"<code>eca_rule_lkt(rule_number)</code>","text":"<p>Generate an ECA rule lookup table.</p> <p>Parameters:</p> Name Type Description Default <code>rule_number</code> <code>int</code> <p>Integer in [0, 255] specifying the rule.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Lookup table of shape (8,) with dtype int8.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_serial_adder_bm.eca_step","title":"<code>eca_step(x, rule, boundary, rng=None)</code>","text":"<p>Advance one step of an elementary cellular automaton.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Current binary state of shape (width,).</p> required <code>rule</code> <code>ndarray</code> <p>Lookup table from <code>eca_rule_lkt</code>.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition (\"periodic\", \"fixed_zero\", \"fixed_one\", \"mirror\", or \"random\").</p> required <code>rng</code> <p>Optional random generator for \"random\" boundary.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Next state of shape (width,) with dtype int8.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_serial_adder_bm.flatten_history","title":"<code>flatten_history(history_list_of_arrays)</code>","text":"<p>Concatenate a list of 1D arrays into a flat feature vector.</p> <p>Parameters:</p> Name Type Description Default <code>history_list_of_arrays</code> <code>List[ndarray]</code> <p>List of 1D arrays with matching shapes.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Flattened 1D vector formed by concatenation.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_serial_adder_bm.int_to_bits_lsb","title":"<code>int_to_bits_lsb(i, n_bits)</code>","text":"<p>Convert an integer to an LSB-first bit vector.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int</code> <p>Integer value to convert.</p> required <code>n_bits</code> <code>int</code> <p>Number of bits in the output vector.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Bit vector of shape (n_bits,) with dtype int8.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_serial_adder_bm.make_packet","title":"<code>make_packet(tag_channel, value)</code>","text":"<p>Create a single tagged packet.</p> <p>Parameters:</p> Name Type Description Default <code>tag_channel</code> <code>int</code> <p>Tag channel index.</p> required <code>value</code> <code>int</code> <p>Bit value (0 or 1).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Packet of shape (5,) with dtype int8.</p>"},{"location":"api/#computingMicrobiome.benchmarks.k_serial_adder_bm.run_episode_record_serial_adder","title":"<code>run_episode_record_serial_adder(a, b, bits, rule_number, width, boundary, itr, d_period, rng, input_locations, reg=None, collect_states=True, x0_mode='zeros')</code>","text":"<p>Run one serial-adder episode and optionally score with a readout.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>Integer A (0 &lt;= a &lt; 2**bits).</p> required <code>b</code> <code>int</code> <p>Integer B (0 &lt;= b &lt; 2**bits).</p> required <code>bits</code> <code>int</code> <p>Bit-width for A and B.</p> required <code>rule_number</code> <code>int</code> <p>ECA rule number (0-255).</p> required <code>width</code> <code>int</code> <p>Number of cells in the automaton.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition.</p> required <code>itr</code> <code>int</code> <p>Number of iterations between ticks.</p> required <code>d_period</code> <code>int</code> <p>Distractor length in input ticks.</p> required <code>rng</code> <code>Generator</code> <p>NumPy random generator.</p> required <code>input_locations</code> <code>ndarray</code> <p>Injection locations array.</p> required <code>reg</code> <code>Optional[Readout]</code> <p>Optional trained readout model for predictions.</p> <code>None</code> <code>collect_states</code> <code>bool</code> <p>Whether to store the full state history.</p> <code>True</code> <code>x0_mode</code> <code>str</code> <p>Initial state mode (\"zeros\" or \"random\").</p> <code>'zeros'</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Episode data including inputs, features, predictions, and states.</p>"},{"location":"api/#tasks","title":"Tasks","text":"<p>Toy addition experiment helpers.</p>"},{"location":"api/#computingMicrobiome.tasks.toy_addition.OP_AND","title":"<code>OP_AND = np.array([1, 0, 0, 0], dtype=(np.int8))</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.tasks.toy_addition.OP_OR","title":"<code>OP_OR = np.array([1, 1, 1, 0], dtype=(np.int8))</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.tasks.toy_addition.OP_XOR","title":"<code>OP_XOR = np.array([0, 1, 1, 0], dtype=(np.int8))</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.tasks.toy_addition.Readout","title":"<code>Readout</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Minimal interface for readout models used in benchmarks.</p>"},{"location":"api/#computingMicrobiome.tasks.toy_addition._full_adder_reservoir_features_with_locations","title":"<code>_full_adder_reservoir_features_with_locations(a, b, cin, *, rule_number, width, boundary, itr, d_period, recurrence, repeats, rng, input_locations, feature_mode='cue_tick', output_window=2)</code>","text":"<p>Reservoir features and labels for one full-adder micro-episode.</p>"},{"location":"api/#computingMicrobiome.tasks.toy_addition.addition_reservoir_features","title":"<code>addition_reservoir_features(x, y, n_bits, cin, **reservoir_params)</code>","text":"<p>Compute reservoir features for N-bit ripple-carry addition.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>First operand as integer.</p> required <code>y</code> <code>int</code> <p>Second operand as integer.</p> required <code>n_bits</code> <code>int</code> <p>Number of bits per operand.</p> required <code>cin</code> <code>int</code> <p>Carry-in bit (0 or 1).</p> required <code>**reservoir_params</code> <p>Reservoir parameters such as rule_number, width, boundary, recurrence, itr, d_period, repeats, seed, feature_mode, and output_window.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Tuple[np.ndarray, np.ndarray]: Feature vector and output bits</p> <code>ndarray</code> <p>(sum bits plus carry).</p>"},{"location":"api/#computingMicrobiome.tasks.toy_addition.apply_opcode","title":"<code>apply_opcode(op_bits_msb_first, a, b)</code>","text":"<p>Apply the opcode-selected Boolean operation.</p> <p>Parameters:</p> Name Type Description Default <code>op_bits_msb_first</code> <code>ndarray</code> <p>Array of shape (4,) in order [op3, op2, op1, op0].</p> required <code>a</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <code>b</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Result bit (0 or 1).</p>"},{"location":"api/#computingMicrobiome.tasks.toy_addition.bit_balance","title":"<code>bit_balance(Y)</code>","text":"<p>Compute p(y=1) for each output bit.</p> <p>Parameters:</p> Name Type Description Default <code>Y</code> <code>ndarray</code> <p>Labels of shape (n_samples, n_bits_out).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Probabilities of shape (n_bits_out,).</p>"},{"location":"api/#computingMicrobiome.tasks.toy_addition.bits_lsb_to_int","title":"<code>bits_lsb_to_int(bits_lsb)</code>","text":"<p>Convert an LSB-first bit vector to an integer.</p> <p>Parameters:</p> Name Type Description Default <code>bits_lsb</code> <code>ndarray</code> <p>Bit vector of shape (n_bits,) in LSB-first order.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Integer value represented by the bit vector.</p>"},{"location":"api/#computingMicrobiome.tasks.toy_addition.bits_to_int","title":"<code>bits_to_int(bits)</code>","text":"<p>Convert LSB-first bits to an integer.</p> <p>Parameters:</p> Name Type Description Default <code>bits</code> <code>Sequence[int]</code> <p>Sequence of bits in LSB-first order.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Integer value.</p>"},{"location":"api/#computingMicrobiome.tasks.toy_addition.build_reservoir_dataset","title":"<code>build_reservoir_dataset(n_bits, cin, **reservoir_params)</code>","text":"<p>Enumerate all x,y pairs and build reservoir features.</p> <p>Parameters:</p> Name Type Description Default <code>n_bits</code> <code>int</code> <p>Number of bits per operand.</p> required <code>cin</code> <code>int</code> <p>Carry-in bit (0 or 1).</p> required <code>**reservoir_params</code> <p>Reservoir parameters.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray]: Feature matrix and label matrix.</p>"},{"location":"api/#computingMicrobiome.tasks.toy_addition.constant_zero_baseline_accuracy","title":"<code>constant_zero_baseline_accuracy(Y)</code>","text":"<p>Compute accuracy per bit if always predicting 0.</p> <p>Parameters:</p> Name Type Description Default <code>Y</code> <code>ndarray</code> <p>Labels of shape (n_samples, n_bits_out).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Accuracy values of shape (n_bits_out,).</p>"},{"location":"api/#computingMicrobiome.tasks.toy_addition.create_input_locations","title":"<code>create_input_locations(width, recurrence, input_channels, rng)</code>","text":"<p>Sample injection sites across the automaton width.</p> <p>The width is partitioned into <code>recurrence</code> segments and <code>input_channels</code> positions are sampled without replacement in each segment.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Total number of cells.</p> required <code>recurrence</code> <code>int</code> <p>Number of segments to partition the width into.</p> required <code>input_channels</code> <code>int</code> <p>Number of channels to inject per segment.</p> required <code>rng</code> <code>Generator</code> <p>NumPy random generator for sampling.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Integer array of length <code>recurrence * input_channels</code>.</p>"},{"location":"api/#computingMicrobiome.tasks.toy_addition.enumerate_addition_dataset","title":"<code>enumerate_addition_dataset(n_bits, cin=0)</code>","text":"<p>Enumerate the full addition dataset.</p> <p>Parameters:</p> Name Type Description Default <code>n_bits</code> <code>int</code> <p>Number of bits per operand.</p> required <code>cin</code> <code>int</code> <p>Carry-in bit (0 or 1).</p> <code>0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Tuple[np.ndarray, np.ndarray]: Input matrix of shape</p> <code>ndarray</code> <p>(2(2n_bits), 2n_bits) and labels of shape</p> <code>Tuple[ndarray, ndarray]</code> <p>(2*(2n_bits), n_bits + 1).</p>"},{"location":"api/#computingMicrobiome.tasks.toy_addition.evaluate_linear_task","title":"<code>evaluate_linear_task(X, Y, *, readout_kind='svm', readout_config=None, seed=0)</code>","text":"<p>Train linear readouts per output bit and report accuracy metrics.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Feature matrix of shape (n_samples, n_features).</p> required <code>Y</code> <code>ndarray</code> <p>Output labels of shape (n_samples, n_bits_out).</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Metrics including per-bit accuracy, full-vector accuracy,</p> <code>dict</code> <p>and baseline statistics.</p>"},{"location":"api/#computingMicrobiome.tasks.toy_addition.evaluate_models","title":"<code>evaluate_models(models, X, Y)</code>","text":"<p>Evaluate per-bit and full-vector accuracy.</p> <p>Parameters:</p> Name Type Description Default <code>models</code> <code>List[Readout]</code> <p>List of trained classifiers (one per output bit).</p> required <code>X</code> <code>ndarray</code> <p>Feature matrix of shape (n_samples, n_features).</p> required <code>Y</code> <code>ndarray</code> <p>Labels of shape (n_samples, n_bits_out).</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Metrics including per-bit accuracy and full-vector accuracy.</p>"},{"location":"api/#computingMicrobiome.tasks.toy_addition.full_adder_reservoir_features","title":"<code>full_adder_reservoir_features(a, b, cin, *, rule_number, width, boundary, itr, d_period, recurrence, repeats, seed, feature_mode='cue_tick', output_window=2)</code>","text":"<p>Reservoir features and labels for a single full-adder step.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <code>b</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <code>cin</code> <code>int</code> <p>Carry-in bit (0 or 1).</p> required <code>rule_number</code> <code>int</code> <p>ECA rule number (0-255).</p> required <code>width</code> <code>int</code> <p>Number of cells in the automaton.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition.</p> required <code>itr</code> <code>int</code> <p>Number of iterations between ticks.</p> required <code>d_period</code> <code>int</code> <p>Delay period between input and recall.</p> required <code>recurrence</code> <code>int</code> <p>Number of input segments for injection.</p> required <code>repeats</code> <code>int</code> <p>Number of episode repeats.</p> required <code>seed</code> <code>int</code> <p>RNG seed.</p> required <code>feature_mode</code> <code>str</code> <p>Feature extraction mode (\"cue_tick\" or \"window\").</p> <code>'cue_tick'</code> <code>output_window</code> <code>int</code> <p>Output window length when using windowed features.</p> <code>2</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Tuple[np.ndarray, np.ndarray, int, int]: Feature vector, label vector,</p> <code>ndarray</code> <p>sum bit, and carry bit.</p>"},{"location":"api/#computingMicrobiome.tasks.toy_addition.int_to_bits","title":"<code>int_to_bits(x, n)</code>","text":"<p>Convert an integer to LSB-first bits.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>Integer value to convert.</p> required <code>n</code> <code>int</code> <p>Number of bits to return.</p> required <p>Returns:</p> Type Description <code>List[int]</code> <p>List[int]: LSB-first bits of length n.</p>"},{"location":"api/#computingMicrobiome.tasks.toy_addition.int_to_bits_lsb","title":"<code>int_to_bits_lsb(i, n_bits)</code>","text":"<p>Convert an integer to an LSB-first bit vector.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int</code> <p>Integer value to convert.</p> required <code>n_bits</code> <code>int</code> <p>Number of bits in the output vector.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Bit vector of shape (n_bits,) with dtype int8.</p>"},{"location":"api/#computingMicrobiome.tasks.toy_addition.majority_baseline_accuracy","title":"<code>majority_baseline_accuracy(Y)</code>","text":"<p>Compute majority-class accuracy per output bit.</p> <p>Parameters:</p> Name Type Description Default <code>Y</code> <code>ndarray</code> <p>Labels of shape (n_samples, n_bits_out).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Accuracy values of shape (n_bits_out,).</p>"},{"location":"api/#computingMicrobiome.tasks.toy_addition.make_readout","title":"<code>make_readout(kind='svm', config=None, *, rng=None)</code>","text":"<p>Create a readout by kind (svm, evo, meta_evo, moran, digital).</p>"},{"location":"api/#computingMicrobiome.tasks.toy_addition.run_episode_record_tagged","title":"<code>run_episode_record_tagged(op_bits_msb_first, a, b, rule_number, width, boundary, itr, d_period, rng, input_locations, repeats=1, order=None, reg=None, collect_states=True, x0_mode='zeros', feature_mode='cue_tick', output_window=2)</code>","text":"<p>Run one tagged-program episode and optionally score with a readout.</p> <p>Parameters:</p> Name Type Description Default <code>op_bits_msb_first</code> <code>ndarray</code> <p>Array of shape (4,) in order [op3, op2, op1, op0].</p> required <code>a</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <code>b</code> <code>int</code> <p>Operand bit (0 or 1).</p> required <code>rule_number</code> <code>int</code> <p>ECA rule number (0-255).</p> required <code>width</code> <code>int</code> <p>Number of cells in the automaton.</p> required <code>boundary</code> <code>str</code> <p>Boundary condition.</p> required <code>itr</code> <code>int</code> <p>Number of iterations between ticks.</p> required <code>d_period</code> <code>int</code> <p>Distractor length in input ticks.</p> required <code>rng</code> <code>Generator</code> <p>NumPy random generator.</p> required <code>input_locations</code> <code>ndarray</code> <p>Injection locations array.</p> required <code>repeats</code> <code>int</code> <p>Number of times to repeat the write packets.</p> <code>1</code> <code>order</code> <code>Optional[Sequence[str]]</code> <p>Optional packet field ordering.</p> <code>None</code> <code>reg</code> <code>Optional[Readout]</code> <p>Optional trained readout model for predictions.</p> <code>None</code> <code>collect_states</code> <code>bool</code> <p>Whether to store the full state history.</p> <code>True</code> <code>x0_mode</code> <code>str</code> <p>Initial state mode (\"zeros\" or \"random\").</p> <code>'zeros'</code> <code>feature_mode</code> <code>str</code> <p>\"cue_tick\" or \"output_window\".</p> <code>'cue_tick'</code> <code>output_window</code> <code>int</code> <p>Window length when feature_mode is \"output_window\".</p> <code>2</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Episode data including inputs, features, predictions, and states.</p>"},{"location":"api/#computingMicrobiome.tasks.toy_addition.train_direct_linear_models","title":"<code>train_direct_linear_models(X_direct, Y, *, readout_kind='svm', readout_config=None, seed=0)</code>","text":"<p>Train one linear readout per output bit.</p> <p>Parameters:</p> Name Type Description Default <code>X_direct</code> <code>ndarray</code> <p>Direct input features of shape (n_samples, 2*n_bits).</p> required <code>Y</code> <code>ndarray</code> <p>Output labels of shape (n_samples, n_bits + 1).</p> required <p>Returns:</p> Type Description <code>List[Readout]</code> <p>List[Readout]: One classifier per output bit.</p>"},{"location":"api/#computingMicrobiome.tasks.toy_addition.train_reservoir_linear_models","title":"<code>train_reservoir_linear_models(X_res, Y, *, readout_kind='svm', readout_config=None, seed=0)</code>","text":"<p>Train one linear readout per output bit on reservoir features.</p> <p>Parameters:</p> Name Type Description Default <code>X_res</code> <code>ndarray</code> <p>Reservoir features of shape (n_samples, n_features).</p> required <code>Y</code> <code>ndarray</code> <p>Output labels of shape (n_samples, n_bits_out).</p> required <p>Returns:</p> Type Description <code>List[Readout]</code> <p>List[Readout]: One classifier per output bit.</p>"},{"location":"api/#plotting","title":"Plotting","text":""},{"location":"api/#computingMicrobiome.plot_utils.DEFAULT_ACTIVE_COLOR","title":"<code>DEFAULT_ACTIVE_COLOR = '#21b0ff'</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.plot_utils.DEFAULT_BG_COLOR","title":"<code>DEFAULT_BG_COLOR = '#f7e9f0'</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.plot_utils.DEFAULT_BORDER_COLOR","title":"<code>DEFAULT_BORDER_COLOR = '#ffffff'</code>  <code>module-attribute</code>","text":""},{"location":"api/#computingMicrobiome.plot_utils._binary_to_rgb_with_border","title":"<code>_binary_to_rgb_with_border(states, *, bg_rgb, active_rgb, border_rgb, cell_size, border_px)</code>","text":""},{"location":"api/#computingMicrobiome.plot_utils._ensure_figures_dir","title":"<code>_ensure_figures_dir(fig_dir=None)</code>","text":""},{"location":"api/#computingMicrobiome.plot_utils._hex_to_rgb","title":"<code>_hex_to_rgb(color)</code>","text":""},{"location":"api/#computingMicrobiome.plot_utils._pad_states","title":"<code>_pad_states(states, target_height)</code>","text":"<p>Pad states with zeros on the bottom to a fixed height.</p>"},{"location":"api/#computingMicrobiome.plot_utils._plot_binary_grid","title":"<code>_plot_binary_grid(ax, data, *, color0, color1, border_color, border_width)</code>","text":""},{"location":"api/#computingMicrobiome.plot_utils._plot_states","title":"<code>_plot_states(ax, states, *, cmap, background_color, active_color, border_color, border_width)</code>","text":""},{"location":"api/#computingMicrobiome.plot_utils._reservoir_params_from_defaults","title":"<code>_reservoir_params_from_defaults()</code>","text":""},{"location":"api/#computingMicrobiome.plot_utils._scale_with_border","title":"<code>_scale_with_border(rgb, *, cell_size, border_px, border_color)</code>","text":""},{"location":"api/#computingMicrobiome.plot_utils._states_to_rgb","title":"<code>_states_to_rgb(states, *, cmap, background_color, active_color, border_color, cell_size, border_px)</code>","text":"<p>Convert binary states to an RGB image array with optional borders.</p>"},{"location":"api/#computingMicrobiome.plot_utils._sum_labels_for_pairs","title":"<code>_sum_labels_for_pairs(n_bits)</code>","text":""},{"location":"api/#computingMicrobiome.plot_utils.build_reservoir_dataset","title":"<code>build_reservoir_dataset(n_bits, cin, **reservoir_params)</code>","text":"<p>Enumerate all x,y pairs and build reservoir features.</p> <p>Parameters:</p> Name Type Description Default <code>n_bits</code> <code>int</code> <p>Number of bits per operand.</p> required <code>cin</code> <code>int</code> <p>Carry-in bit (0 or 1).</p> required <code>**reservoir_params</code> <p>Reservoir parameters.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray]: Feature matrix and label matrix.</p>"},{"location":"api/#computingMicrobiome.plot_utils.enumerate_addition_dataset","title":"<code>enumerate_addition_dataset(n_bits, cin=0)</code>","text":"<p>Enumerate the full addition dataset.</p> <p>Parameters:</p> Name Type Description Default <code>n_bits</code> <code>int</code> <p>Number of bits per operand.</p> required <code>cin</code> <code>int</code> <p>Carry-in bit (0 or 1).</p> <code>0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Tuple[np.ndarray, np.ndarray]: Input matrix of shape</p> <code>ndarray</code> <p>(2(2n_bits), 2n_bits) and labels of shape</p> <code>Tuple[ndarray, ndarray]</code> <p>(2*(2n_bits), n_bits + 1).</p>"},{"location":"api/#computingMicrobiome.plot_utils.evaluate_linear_task","title":"<code>evaluate_linear_task(X, Y, *, readout_kind='svm', readout_config=None, seed=0)</code>","text":"<p>Train linear readouts per output bit and report accuracy metrics.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Feature matrix of shape (n_samples, n_features).</p> required <code>Y</code> <code>ndarray</code> <p>Output labels of shape (n_samples, n_bits_out).</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Metrics including per-bit accuracy, full-vector accuracy,</p> <code>dict</code> <p>and baseline statistics.</p>"},{"location":"api/#computingMicrobiome.plot_utils.figure_ablation_itr","title":"<code>figure_ablation_itr(fig_dir, n_bits, itr_list)</code>","text":"<p>Generate accuracy vs itr ablation figure.</p> <p>Parameters:</p> Name Type Description Default <code>fig_dir</code> <code>str</code> <p>Output directory for figures.</p> required <code>n_bits</code> <code>int</code> <p>Bit-width to evaluate.</p> required <code>itr_list</code> <code>list[int]</code> <p>Iteration counts to sweep.</p> required"},{"location":"api/#computingMicrobiome.plot_utils.figure_full_accuracy_vs_n","title":"<code>figure_full_accuracy_vs_n(fig_dir, n_list)</code>","text":"<p>Generate full-vector accuracy vs N plot and results.</p> <p>Parameters:</p> Name Type Description Default <code>fig_dir</code> <code>str</code> <p>Output directory for figures.</p> required <code>n_list</code> <code>list[int]</code> <p>List of bit-widths to evaluate.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: Results per bit-width for direct and reservoir models.</p>"},{"location":"api/#computingMicrobiome.plot_utils.figure_pca_direct_vs_reservoir","title":"<code>figure_pca_direct_vs_reservoir(fig_dir, n_bits)</code>","text":"<p>Generate PCA comparison for direct vs reservoir features.</p> <p>Parameters:</p> Name Type Description Default <code>fig_dir</code> <code>str</code> <p>Output directory for figures.</p> required <code>n_bits</code> <code>int</code> <p>Bit-width to evaluate.</p> required"},{"location":"api/#computingMicrobiome.plot_utils.figure_per_bit_accuracy_and_balance","title":"<code>figure_per_bit_accuracy_and_balance(fig_dir, n_bits)</code>","text":"<p>Generate per-bit accuracy and balance figure.</p> <p>Parameters:</p> Name Type Description Default <code>fig_dir</code> <code>str</code> <p>Output directory for figures.</p> required <code>n_bits</code> <code>int</code> <p>Bit-width to evaluate.</p> required"},{"location":"api/#computingMicrobiome.plot_utils.main","title":"<code>main()</code>","text":"<p>Generate all toy addition figures into the figures directory.</p>"},{"location":"api/#computingMicrobiome.plot_utils.make_spacetime_gif","title":"<code>make_spacetime_gif(states, path, *, reveal_mode='grow', duration_ms=60, cmap=None, background_color=DEFAULT_BG_COLOR, active_color=DEFAULT_ACTIVE_COLOR, border_color=DEFAULT_BORDER_COLOR, cell_size=6, border_px=1, loop=0)</code>","text":"<p>Create a GIF that reveals the space-time diagram over time.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>ndarray</code> <p>Binary state history of shape (T, width).</p> required <code>path</code> <code>str | Path</code> <p>Output file path.</p> required <code>reveal_mode</code> <code>str</code> <p>\"grow\" (incremental rows) or \"slide\" (moving window).</p> <code>'grow'</code> <code>duration_ms</code> <code>int</code> <p>Frame duration in milliseconds.</p> <code>60</code> <code>cmap</code> <code>Optional[str]</code> <p>Optional matplotlib colormap name.</p> <code>None</code> <code>background_color</code> <code>str</code> <p>Color for inactive cells.</p> <code>DEFAULT_BG_COLOR</code> <code>active_color</code> <code>str</code> <p>Color for active cells.</p> <code>DEFAULT_ACTIVE_COLOR</code> <code>border_color</code> <code>str</code> <p>Color for cell borders.</p> <code>DEFAULT_BORDER_COLOR</code> <code>cell_size</code> <code>int</code> <p>Pixel size of each cell.</p> <code>6</code> <code>border_px</code> <code>int</code> <p>Border thickness in pixels.</p> <code>1</code> <code>loop</code> <code>int</code> <p>GIF loop count (0 = infinite).</p> <code>0</code> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Path to the saved GIF file.</p>"},{"location":"api/#computingMicrobiome.plot_utils.plot_activity","title":"<code>plot_activity(states, title='Activity over time', *, line_color=DEFAULT_ACTIVE_COLOR, background_color=DEFAULT_BG_COLOR, show=True)</code>","text":"<p>Plot the fraction of active cells at each time step.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>ndarray</code> <p>Binary state history of shape (T, width).</p> required <code>title</code> <code>str</code> <p>Plot title.</p> <code>'Activity over time'</code> <code>line_color</code> <code>str</code> <p>Line color.</p> <code>DEFAULT_ACTIVE_COLOR</code> <code>background_color</code> <code>str</code> <p>Background color.</p> <code>DEFAULT_BG_COLOR</code> <code>show</code> <code>bool</code> <p>Whether to call plt.show().</p> <code>True</code> <p>Returns:</p> Type Description <code>Axes</code> <p>plt.Axes: Axes containing the plot.</p>"},{"location":"api/#computingMicrobiome.plot_utils.plot_entropy","title":"<code>plot_entropy(states, title='Shannon entropy over time', *, line_color=DEFAULT_ACTIVE_COLOR, background_color=DEFAULT_BG_COLOR, show=True)</code>","text":"<p>Plot per-time-step Shannon entropy for binary CA states.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>ndarray</code> <p>Binary state history of shape (T, width).</p> required <code>title</code> <code>str</code> <p>Plot title.</p> <code>'Shannon entropy over time'</code> <code>line_color</code> <code>str</code> <p>Line color.</p> <code>DEFAULT_ACTIVE_COLOR</code> <code>background_color</code> <code>str</code> <p>Background color.</p> <code>DEFAULT_BG_COLOR</code> <code>show</code> <code>bool</code> <p>Whether to call plt.show().</p> <code>True</code> <p>Returns:</p> Type Description <code>Axes</code> <p>plt.Axes: Axes containing the plot.</p>"},{"location":"api/#computingMicrobiome.plot_utils.plot_red_green_grid","title":"<code>plot_red_green_grid(correctness, title='')</code>","text":"<p>Plot correctness grid with red/green tiles.</p> <p>Parameters:</p> Name Type Description Default <code>correctness</code> <code>ndarray</code> <p>Array of shape (n_trials, bits) with values {-1, +1}.</p> required <code>title</code> <code>str</code> <p>Plot title.</p> <code>''</code>"},{"location":"api/#computingMicrobiome.plot_utils.plot_rule_table","title":"<code>plot_rule_table(rule, *, background_color=DEFAULT_BG_COLOR, active_color=DEFAULT_ACTIVE_COLOR, border_color=DEFAULT_BORDER_COLOR, border_width=0.4, show=True)</code>","text":"<p>Plot the 8 neighborhood patterns and outputs for an ECA rule.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>int</code> <p>ECA rule number (0-255).</p> required <code>background_color</code> <code>str</code> <p>Color for inactive cells.</p> <code>DEFAULT_BG_COLOR</code> <code>active_color</code> <code>str</code> <p>Color for active cells.</p> <code>DEFAULT_ACTIVE_COLOR</code> <code>border_color</code> <code>str</code> <p>Color for cell borders.</p> <code>DEFAULT_BORDER_COLOR</code> <code>border_width</code> <code>float</code> <p>Border line width.</p> <code>0.4</code> <code>show</code> <code>bool</code> <p>Whether to call plt.show().</p> <code>True</code> <p>Returns:</p> Type Description <code>Axes</code> <p>plt.Axes: Axes containing the plot.</p>"},{"location":"api/#computingMicrobiome.plot_utils.plot_snapshot","title":"<code>plot_snapshot(states, time_step, *, background_color=DEFAULT_BG_COLOR, active_color=DEFAULT_ACTIVE_COLOR, border_color=DEFAULT_BORDER_COLOR, border_width=0.2, show=True)</code>","text":"<p>Plot a single time slice of the automaton.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>ndarray</code> <p>Binary state history of shape (T, width).</p> required <code>time_step</code> <code>int</code> <p>Time step index to plot.</p> required <code>background_color</code> <code>str</code> <p>Color for inactive cells.</p> <code>DEFAULT_BG_COLOR</code> <code>active_color</code> <code>str</code> <p>Color for active cells.</p> <code>DEFAULT_ACTIVE_COLOR</code> <code>border_color</code> <code>str</code> <p>Color for cell borders.</p> <code>DEFAULT_BORDER_COLOR</code> <code>border_width</code> <code>float</code> <p>Border line width.</p> <code>0.2</code> <code>show</code> <code>bool</code> <p>Whether to call plt.show().</p> <code>True</code> <p>Returns:</p> Type Description <code>Axes</code> <p>plt.Axes: Axes containing the plot.</p>"},{"location":"api/#computingMicrobiome.plot_utils.plot_spacetime","title":"<code>plot_spacetime(states, title='', *, cmap=None, background_color=DEFAULT_BG_COLOR, active_color=DEFAULT_ACTIVE_COLOR, border_color=DEFAULT_BORDER_COLOR, border_width=0.2, ax=None, show=True)</code>","text":"<p>Plot a space-time diagram for cellular automata states.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>ndarray</code> <p>Binary state history of shape (T, width).</p> required <code>title</code> <code>str</code> <p>Plot title.</p> <code>''</code> <code>cmap</code> <code>Optional[str]</code> <p>Optional matplotlib colormap name.</p> <code>None</code> <code>background_color</code> <code>str</code> <p>Color for inactive cells.</p> <code>DEFAULT_BG_COLOR</code> <code>active_color</code> <code>str</code> <p>Color for active cells.</p> <code>DEFAULT_ACTIVE_COLOR</code> <code>border_color</code> <code>str</code> <p>Color for cell borders.</p> <code>DEFAULT_BORDER_COLOR</code> <code>border_width</code> <code>float</code> <p>Border line width.</p> <code>0.2</code> <code>ax</code> <code>Optional[Axes]</code> <p>Optional matplotlib Axes to draw into.</p> <code>None</code> <code>show</code> <code>bool</code> <p>Whether to call plt.show().</p> <code>True</code> <p>Returns:</p> Type Description <code>Axes</code> <p>plt.Axes: Axes containing the plot.</p>"},{"location":"api/#computingMicrobiome.plot_utils.plot_spacetime_with_density","title":"<code>plot_spacetime_with_density(states, title='', *, cmap=None, background_color=DEFAULT_BG_COLOR, active_color=DEFAULT_ACTIVE_COLOR, border_color=DEFAULT_BORDER_COLOR, border_width=0.2, show=True)</code>","text":"<p>Plot space-time diagram plus density-over-time.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>ndarray</code> <p>Binary state history of shape (T, width).</p> required <code>title</code> <code>str</code> <p>Plot title.</p> <code>''</code> <code>cmap</code> <code>Optional[str]</code> <p>Optional matplotlib colormap name.</p> <code>None</code> <code>background_color</code> <code>str</code> <p>Color for inactive cells.</p> <code>DEFAULT_BG_COLOR</code> <code>active_color</code> <code>str</code> <p>Color for active cells.</p> <code>DEFAULT_ACTIVE_COLOR</code> <code>border_color</code> <code>str</code> <p>Color for cell borders.</p> <code>DEFAULT_BORDER_COLOR</code> <code>border_width</code> <code>float</code> <p>Border line width.</p> <code>0.2</code> <code>show</code> <code>bool</code> <p>Whether to call plt.show().</p> <code>True</code> <p>Returns:</p> Type Description <code>Tuple[Axes, Axes]</code> <p>Tuple[plt.Axes, plt.Axes]: Axes for the space-time and density plots.</p>"},{"location":"api/#computingMicrobiome.plot_utils.plot_xor_batch_summary","title":"<code>plot_xor_batch_summary(inputs_a, y_pred, y_true, *, title='', background_color=DEFAULT_BG_COLOR, active_color=DEFAULT_ACTIVE_COLOR, border_color=DEFAULT_BORDER_COLOR, border_width=0.4, show=True)</code>","text":"<p>Plot side-by-side heatmaps for XOR batch runs.</p> <p>Parameters:</p> Name Type Description Default <code>inputs_a</code> <code>ndarray</code> <p>Input bits for operand A, shape (n_trials, n_bits).</p> required <code>y_pred</code> <code>ndarray</code> <p>Predicted outputs, shape (n_trials, n_bits).</p> required <code>y_true</code> <code>ndarray</code> <p>True outputs, shape (n_trials, n_bits).</p> required <code>title</code> <code>str</code> <p>Plot title.</p> <code>''</code> <code>background_color</code> <code>str</code> <p>Background color.</p> <code>DEFAULT_BG_COLOR</code> <code>active_color</code> <code>str</code> <p>Active cell color.</p> <code>DEFAULT_ACTIVE_COLOR</code> <code>border_color</code> <code>str</code> <p>Border color.</p> <code>DEFAULT_BORDER_COLOR</code> <code>border_width</code> <code>float</code> <p>Border line width.</p> <code>0.4</code> <code>show</code> <code>bool</code> <p>Whether to call plt.show().</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[Axes, Axes, Axes]</code> <p>Tuple[plt.Axes, plt.Axes, plt.Axes]: Axes for inputs, predictions, correctness.</p>"},{"location":"api/#computingMicrobiome.plot_utils.plot_xor_classification_summary","title":"<code>plot_xor_classification_summary(inputs, y_pred_single, y_true_single, *, title='', background_color=DEFAULT_BG_COLOR, active_color=DEFAULT_ACTIVE_COLOR, correct_color='#2ca02c', wrong_color='#d62728', border_color=DEFAULT_BORDER_COLOR, border_width=0.4, show=True)</code>","text":"<p>Plot side-by-side heatmaps for XOR batch runs (single-bit output).</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>ndarray</code> <p>Input bits, shape (n_trials, n_bits).</p> required <code>y_pred_single</code> <code>ndarray</code> <p>Predicted outputs, shape (n_trials,).</p> required <code>y_true_single</code> <code>ndarray</code> <p>True outputs, shape (n_trials,).</p> required <code>title</code> <code>str</code> <p>Plot title.</p> <code>''</code> <code>background_color</code> <code>str</code> <p>Background color.</p> <code>DEFAULT_BG_COLOR</code> <code>active_color</code> <code>str</code> <p>Active cell color.</p> <code>DEFAULT_ACTIVE_COLOR</code> <code>correct_color</code> <code>str</code> <p>Color for correct predictions.</p> <code>'#2ca02c'</code> <code>wrong_color</code> <code>str</code> <p>Color for incorrect predictions.</p> <code>'#d62728'</code> <code>border_color</code> <code>str</code> <p>Border color.</p> <code>DEFAULT_BORDER_COLOR</code> <code>border_width</code> <code>float</code> <p>Border line width.</p> <code>0.4</code> <code>show</code> <code>bool</code> <p>Whether to call plt.show().</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[Axes, Axes, Axes]</code> <p>Tuple[plt.Axes, plt.Axes, plt.Axes]: Axes for inputs, predictions, correctness.</p>"},{"location":"api/#computingMicrobiome.plot_utils.plot_xor_episode","title":"<code>plot_xor_episode(states, inputs, output_tick, y_true, y_pred=None, *, title='', background_color=DEFAULT_BG_COLOR, active_color=DEFAULT_ACTIVE_COLOR, border_color=DEFAULT_BORDER_COLOR, border_width=0.2, show=True)</code>","text":"<p>Plot XOR episode with spacetime diagram and input timeline.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>ndarray</code> <p>Binary state history of shape (T, width).</p> required <code>inputs</code> <code>ndarray</code> <p>Input stream of shape (L, 4).</p> required <code>output_tick</code> <code>int</code> <p>Index of output tick in [0, L-1].</p> required <code>y_true</code> <code>int</code> <p>True output bit.</p> required <code>y_pred</code> <code>int | None</code> <p>Optional predicted output bit.</p> <code>None</code> <code>title</code> <code>str</code> <p>Plot title.</p> <code>''</code> <code>background_color</code> <code>str</code> <p>Background color.</p> <code>DEFAULT_BG_COLOR</code> <code>active_color</code> <code>str</code> <p>Active cell color.</p> <code>DEFAULT_ACTIVE_COLOR</code> <code>border_color</code> <code>str</code> <p>Border color.</p> <code>DEFAULT_BORDER_COLOR</code> <code>border_width</code> <code>float</code> <p>Border line width.</p> <code>0.2</code> <code>show</code> <code>bool</code> <p>Whether to call plt.show().</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[Axes, Axes]</code> <p>Tuple[plt.Axes, plt.Axes]: Axes for states and inputs.</p>"},{"location":"api/#computingMicrobiome.plot_utils.plot_xor_series","title":"<code>plot_xor_series(inputs, outputs, *, show_aux_channels=False, title='', background_color=DEFAULT_BG_COLOR, active_color=DEFAULT_ACTIVE_COLOR, border_color=DEFAULT_BORDER_COLOR, border_width=0.2, show=True)</code>","text":"<p>Plot XOR input/output series as timelines.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>ndarray</code> <p>Input stream of shape (L, 4) with channels [A, B, distractor, cue].</p> required <code>outputs</code> <code>ndarray</code> <p>Output series of shape (L,) with values {0,1} in output window, else -1.</p> required <code>show_aux_channels</code> <code>bool</code> <p>Whether to include distractor and cue channels.</p> <code>False</code> <code>title</code> <code>str</code> <p>Plot title.</p> <code>''</code> <code>background_color</code> <code>str</code> <p>Background color.</p> <code>DEFAULT_BG_COLOR</code> <code>active_color</code> <code>str</code> <p>Active cell color.</p> <code>DEFAULT_ACTIVE_COLOR</code> <code>border_color</code> <code>str</code> <p>Border color.</p> <code>DEFAULT_BORDER_COLOR</code> <code>border_width</code> <code>float</code> <p>Border line width.</p> <code>0.2</code> <code>show</code> <code>bool</code> <p>Whether to call plt.show().</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[Axes, Axes]</code> <p>Tuple[plt.Axes, plt.Axes]: Axes for inputs and outputs.</p>"},{"location":"api/#computingMicrobiome.plot_utils.plot_xor_summary","title":"<code>plot_xor_summary(inputs, y_true, y_pred, *, title='', background_color=DEFAULT_BG_COLOR, active_color=DEFAULT_ACTIVE_COLOR, border_color=DEFAULT_BORDER_COLOR, border_width=0.2, show=True)</code>","text":"<p>Plot side-by-side heatmaps: inputs, predictions, correctness.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>ndarray</code> <p>Input stream of shape (L, 4).</p> required <code>y_true</code> <code>ndarray</code> <p>True output series of shape (L,) with -1 outside output window.</p> required <code>y_pred</code> <code>ndarray</code> <p>Predicted output series of shape (L,) with -1 outside output window.</p> required <code>title</code> <code>str</code> <p>Plot title.</p> <code>''</code> <code>background_color</code> <code>str</code> <p>Background color.</p> <code>DEFAULT_BG_COLOR</code> <code>active_color</code> <code>str</code> <p>Active cell color.</p> <code>DEFAULT_ACTIVE_COLOR</code> <code>border_color</code> <code>str</code> <p>Border color.</p> <code>DEFAULT_BORDER_COLOR</code> <code>border_width</code> <code>float</code> <p>Border line width.</p> <code>0.2</code> <code>show</code> <code>bool</code> <p>Whether to call plt.show().</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[Axes, Axes, Axes]</code> <p>Tuple[plt.Axes, plt.Axes, plt.Axes]: Axes for inputs, predictions, correctness.</p>"},{"location":"api/#computingMicrobiome.plot_utils.save_spacetime_image","title":"<code>save_spacetime_image(states, path, *, title='', cmap=None, background_color=DEFAULT_BG_COLOR, active_color=DEFAULT_ACTIVE_COLOR, border_color=DEFAULT_BORDER_COLOR, border_width=0.2, dpi=150)</code>","text":"<p>Save a space-time plot as a static image.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>ndarray</code> <p>Binary state history of shape (T, width).</p> required <code>path</code> <code>str | Path</code> <p>Output file path or directory.</p> required <code>title</code> <code>str</code> <p>Plot title.</p> <code>''</code> <code>cmap</code> <code>Optional[str]</code> <p>Optional matplotlib colormap name.</p> <code>None</code> <code>background_color</code> <code>str</code> <p>Color for inactive cells.</p> <code>DEFAULT_BG_COLOR</code> <code>active_color</code> <code>str</code> <p>Color for active cells.</p> <code>DEFAULT_ACTIVE_COLOR</code> <code>border_color</code> <code>str</code> <p>Color for cell borders.</p> <code>DEFAULT_BORDER_COLOR</code> <code>border_width</code> <code>float</code> <p>Border line width.</p> <code>0.2</code> <code>dpi</code> <code>int</code> <p>Output resolution.</p> <code>150</code> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Path to the saved image file.</p>"},{"location":"cli/","title":"Command Line Interface","text":"<p>After installation, the following console scripts are available:</p> <pre><code>cm-make-figures\ncm-opcode-test\ncm-opcode16-test\ncm-compound-opcode-test\ncm-serial-adder-test\ncm-kbit-memory-test\ncm-kxor-visual\ncm-rule110-gif\n</code></pre> <p>Repository-level experiments are run directly:</p> <pre><code>python -m experiments.run_toy_addition_experiment\npython -m experiments.compare_readouts\n</code></pre> <p>Example:</p> <pre><code>cm-make-figures\n</code></pre>"}]}